
Computer Science 130 - Software Engineering

http://web.cs.ucla.edu/classes/spring16/cs130

35%    final exam (open book/notes)
15%    midterm (April 27) (open book/notes)
40%    project
2.5%   requirements homework
7.5%   quizzes (closed book)

June 5 drop-dead date, last day of instruction


Paul Eggert background

  student at UCLA
  did not take software engineering because field did not exist
  became faculty for 3 years and got bored
  left university and started company -> crashed in 5 years
  worked for second largest computer company in the world (Unisys, power of^2)
  another startup -> 12 years (< 50 employees)
  UCLA (after that)

  back-and-forth between academia and industry

==============
Mar. 28, 2016
==============

1. real-world-ish project

   build code that somebody really wants and does not have before
   ideally it should have a client with requirements
   interact with client and produce what client wants

   outside clients, on/off campus, they will not know about software
   ------------------------------------------------------------------
   - IBM
   - Aerospace
   - Anderson School of UCLA
   - Psychology Department
   - Calthorp School

   work in teams of 5, 2-3 teams/client
   -------------------------------------
   - cooperating, where two teams work on different parts of project and
     integrate the whole project in the end
   - competing, where different teams take different approaches to the same
     project

  student projects are also welcome
  ----------------------------------

  project open-source only, typically BSD, GNU, Apache, MIT licensed
  -------------------------------------------------------------------

2. engineering process and practice (higher-level)

   how software engineering works
   almost social-science
   how engineers work with/against each other to build something that works

   how this process works, or doesn't work

   instead of dealing with software, deal with the methods and ways of
   developing the software

3. construction (lower-level)

   know program you want to build, what are the methods and best practices for
   building this piece of software

   actual construction details of software
   ----------------------------------------
   - testing & debugging
   - modularization techniques

   may seem obvious but are actually not
   may be confusing and have pitfalls

   learn not to obvious things in 'obvious' things


What is of software and why is it different?
---------------------------------------------
- set of rules a computer follows
  
  microcode in commercial chips is not included as software
    hardwired into the CPU
    cannot be changed at all

  firmware is not software either
    halfway between hardware & software
    code that is tightly bound with hardware
    low-level code + hard to change (ROM)

    we can write very low-level code
    this is software but very low-level code
    calculate a random number

      // x86-64 machine, includes instruction
      // return a random number 0 ~ 2^63 - 1
      // this works only on x86-64 Hasweller machine
      long randnum(void) { asm ("RDRAND"); }


  1. software is easy to change
     ---------------------------
     mutability of instructions
     mutability brings forth engineering problems that make software hard

  2. it's not manufactured in the traditional sense
     -----------------------------------------------
     don't have to worry about manufacturing
     - type 'cp' or 'scp' to copy program and ship

  3. it doesn't wear out
     --------------------
     don't have to worry about parts wearing out
     parts fail -> lubrication/replacement/repair
     can run program any number of times you want

     hardware failure rate (bathtub curve)
       break-in period: not manufactured correctly
       wear out: finally breaks down because of time

     software failure rate (spikey bathtub curve)
       increases failure rate with each new release
       decreases failure rate as bugs get fixed
       failure rate increases overall as software gets bigger

  4. there are no spare parts
     -------------------------
     if program crashes, replacing with same new copy will not fix it
     
     - maybe revert to previous version
       gzip 1.7 on Solaris 10 with Oracle cc x86-64 crashes
         configuration uses match.S  <-- machine code does not run, dumps core
       gzip 1.6 on this platform (can be considered spare part)

     - maybe substitute a different implementation
       use pigz instead
         different implementation of gzip compression algorithm
         runs in parallel


What is software engineering?
------------------------------
1960s: software was out of control
       "software crisis": too many bugs in software
       need discipline for software development

F.L. Baver (1969): the [establishment] and [use] of [sound] [engineering]
                   principles in order to obtain [economically] software that
                   is [reliable] and works [efficiently] on [real machines]

this definition did not include teamwork


Shellshock Bug (reported 2014-09-24)
-------------------------------------
bug in bash

  $ cp = '(){ ... }'
  $ export cp

this treated 'cp' as a function definition
then running 'cp a b' would run the function above
this bug had been in bash for 20 years

San Diego Union (reported 1994-04-27)
--------------------------------------
DMV spent $44 million on software that doesn't work and will never work
nobody was responsible

wanted to convert circa 1960 database to modern relational database
had bottleneck that could not handle the load that the DMV threw at it


* Most software projects fail.


Alternatives to software engineering
-------------------------------------
* add people to a late project
  often not a good idea

* outsourcing
  outsource to another group
  hire contractor, and let somebody else do the job
  sometimes works, but 'distance' will be a problem
  lose control of the software (intellectual rights access)

* vague objectives and requirements constantly changing
  "agile development"
  sometimes works but often doesn't

* fire and forget
  get some code out the door by the stated deadline and never touching again

* code is all there is
  don't bother to write documentation becuase it is a hassle and probably
  doesn't match the code either

* voluminous PPM (Policies & Procedures Manuals)
  software development process that documents everything
  software development process takes much longer than it may take
  good for developing reliable software
  and proving that it is reliable


software engineering           vs.           computer science
----------------------------------------------------------------------
practical problems of                        theory & methods that
 producing software                            underly programs

software engineering           vs.           system engineering
----------------------------------------------------------------------
just software plus                       software, hardware, firmware 
 human interface                                process design
                                                    policy


==============
Mar. 30, 2016
==============

Presentations for projects

1. The Aerospace Corporation (Mustafa Alammar)
   Enterprise Information Systems/AppDev

   Aerocube-7

   Mission Assurance
     making sure rockets launch successfully
     consulting company
     helping SpaceX certify rockets
     launch national satellites

     SpaceX, NRO Satellites, U.S. Space Systems, Cyber Security

   R&D
     space systems
     spectral imaging
     small satellites (micro/pico-satellites)

   VAEROS
     more on civil and commercial customers, NASA and SpaceX
     'container inspection tests at Port of Oakland'
     modeling and simulation
     CI security

   technology used: SQL, PHP, Java, HTML, CSS, JavaScript, AngularJS


 Last year: orbital debris tracking

   Center for Orbital Reentry & Depris Studies (CORDS)
     tracking orbital debris
     visualizing and tracking for all
   
   Junk Explorer
     MySQL
     Bootstrap
     Google Earth/Maps
     www.space-track.org
     Digital Ocean


 This year: cyber security

   http://map.norsecorp.com/

   develop site and server security intrusion detection, monitoring and more
   develop plugins, applications, algorithms, or systems to detect and
     defend against security vulnerabilities on pubilc-facing websites

   Requirements
   
   (1) makes a measurable or testable difference in improving site security
         DDoS mitigation of security vulnerabilities detected or eliminated
         span detection/removal
         success rate of 'hack' removal

   (2) easy to use or install
         if (application.needsConstantAttention == true)
           application.uninstall

   (3) reliable
         if (application.falsePositiveRate > 0.1)
           application.uninstall()       

   (4) leverage existing solutions
    
        APIs
          Akismet
          ReCAPTCHA
          CLOUDFARE
      
        fill in the gaps
          usability
          effectiveness
          ease of installation
          cost
          compatibility
      
        remember the user


2. Connexity

   tech-driven marketing solutions company
   connect reteailers to customers they care about

   used to be called Shopzilla

   Project: Publisher Challenge
   -----------------------------
   use the Shopzilla Catalog API to build own shopping website
   expose shopping content
   develop back-end and front-end components of shopping site
   compete for most redirects and 'revenue'

   Challenges
   -----------
   API integration
   what data should your website use
   determining what additional information would be useful
   completing the flow-API -> backend logic -> front-end display

   Technologies
   -------------
   enterprise level technologies
     Java
     Spring MVC
   UI component
   interaction with API

   Logistics
   ----------
   mentorship from former cs130 students
   direct experience with enterprise level engineering practices
   setup guidelines
   onsite development workshops
   Git/Github
   various methods of communication between teams and Connexity


3. International Business Machines (IBM)

   Project Lead: Gergana Markova   gmarkova@us.ibm.com
   Dean Okamura    dean.cs130@gmail.com
   Michael Stein   mastein@us.ibm.com
   Neil Sahota     nsahota@us.ibm.com

   team project planning
   collaboration, networking
   rapid decision making
   open source community involvement
   agile development
   globalization awareness
   design thinking and user experience
   reserach and resources evaluation

   Cool cs130 IBM projects
   ------------------------
   Barcode Wallet
     -> Apple Pay
   Volunteer snack delivery service
     -> Uber
   Jazz festival
   Tutoring website enhancements


4. Anderson School at UCLA
   
   cyber security for small businesses
   

=============
Apr. 1, 2016
=============

Jae Lee
TA OH: 2-4 PM Wed.

name
skills/resume
top 5 project preferences


requirements gathering exercies
--------------------------------
Paul Eggert, senior FAA admin
hire company with software developers to solve problem with software
probably some hardware

problem: drones
make country air space safe, aircraft traffic
worst: plane crash, loss of life
dealing with drones because they are threat to air traffic safety
report of drones within few meters of commercial aircraft
afraid of crash and people get killed

software solution to part of this problem
manage drone issues
in realitiy drones can be small to much larger unmanned aircraft
want system to keep track of all of this stuff
not too worried about large drones, who have lots of money
most worried about small drones

require drones operators to register their drones on website
pay $5 for registration
not every drone use has registered
fine of operating drone without licence

should be able to grab drone serial number and find owner

have website with serial number with names and everything else
really unorganized about this
data sitting in server, which is not very useful

senario: firefighters putting out fires in mountains, but spotted drones near
facilities, so couldn't fly
want to find the owner of the drone

want software that gives information to law enforcement facilities when
dealing with illegal drones

information have to be private
general public cannot find owner through serial number

mostly concerned with airport safety but firefighting case is also important
fire department can get FAA to establish a temporary no-fly zone

make data available to LAPD if needed
real goal to prevent drones from causing safety problems

may want total control over drones in the future
e.g. button that can safely land the drones and accessible to police

should have audit trail for all accesses to data and entering of data

should have images that can be matched to low quality images taken by pilots
could try to identify the signal controlling the drone

                  Wi-Fi
cell phone   --------------->   controller  --------------->  drone
                encrypted                      encrypted

Wi-Fi (WEP) is easily crackable
security on drones and controllers is terrible

drones cannot be identified by radar
want to add transponder so that if we point radar at them, we get signal back
want transponder in database for indentification
drone makers reluctant to add transponder due to weight and size
users will take transponder down
if this happens, will like to track down owner and quesiton why turned it off
cannot take down the drones, which are hard

will also work with custom-made drones
such as, must install transponder

priority: people goofing off flying into airports just to fool around

should not lose data due to disk crashes

new owner should register if bought from previous owner

how to get serial number if we do not take drone down
transponders come with serial numbers

2-3 million dollars
time frame 18 months

want this to work on police laptops and cellphones


=============
Apr. 4, 2016
=============

5. Calthorp School (Principal)
   
   standardized testingw as a big deal
   stayed in good standing

   from public school system to independent schools (private schools)

   have to ability to choose
   resources & autonomy

   schools have collected huge amounts of data
   but schools are terrible at analyzing the data
   find patterns

   data -> analysis -> trends -> areas of exploration -> questions
   -> hypotheses -> confimation/invalidation


6. Department of Psychology

   web-based tool to find career he/she is passionate about

   research team of undergrad students at UCLA
   career websites focus on interest... but what about passion?

   Pandora-like algorithm
   like or dislike

   world of work to classify


7. Beehive

   make social media analytics available to all


8. Airbnb for restaurants


9. Connoisseur

   ineffeciencies in finding next dining experience


10. Sugar-Watch
     
    glucose monitor
    how it affects the body
    partner with 2 doctors at UCLA Medical Center & Anderson School

    600 billion dollar market

    doctor & patient needs
    real time data on glucose levels


11. Aerospace Coporation

    federally funded research centers
    works in the national interest


=============
Apr. 6, 2016
=============

Why do we need requirements?
-----------------------------
* developers != users
* legal, contract reasons
* reliability/safety is crucial
* security (tricy in practice)

How much work to put into requirements?
How long/big is the requirements document?
-------------------------------------------
it dependes on the project
the more of the above required, the longer it will get


* one of the most common requirements document problem is that customers would
not want to read the long and obvious document because they are specifying
what the customers already know.


Requirement Engineering
------------------------
applying sound engineering principles to come up with requirements documents

                     requirements
    stakeholders <---------+--------> design
                           |
    - everybody who        |
    cares about            |
    the software           |
    - users/managers       |
                           |
    system model <---------+

    - in developers' heads


Good Requirements
------------------

- are testable (once system is implemented)
  ideally would want to make it quantifiable
  realistically turn it from something vague to something less vague
  "build a system where the UI is userfriendly"
    this is not testable
    change to something testable
    we could test them on users

- are feasible (in the indented environment)
  make sure requirements are actually doable
  do not make NP-complete requirements

- don't conflict with each other
  conflict are not obvious
  come from different parts of the requirements document
  gathered from different parts of the customer organization
  inconsistent requirements documents arise with conflicting user intentions
  conflicts may not be obvious and may reflect conflicts among users

- are attributed (to specific source)
  can go to any requirement in document and see who is responsible
  each requirement should be attributed to specific source
  should know who to ask if there is a problem in the requirements

- are bounded
  do not want to have requirement that is infinitely hard to satisfy
  should know when the requirements are satisfied
  "as fast as possible"
  do not want software engineers to develop "forever"

- are unambiguous
  ambiguous: so few requirements or so poorly stated so that they can be
             interpreted in many different ways
  should avoid the ambiguity (English is ambiguous)
  need somthing functional

- are essential
  Aristotle: get at heart/core of the story
             find out what really matters
             this is called the "essence"
  good requirements should focus on the essential part of the application
  and not trivial details

- are specified at the user level
  write in natural language that the user understands
  do not write in code-like languages such as Java, C, Shell Script

- match the system's vision
  when you try to change the world with your application, you should know what
  the world looks like after your application

- are prioritized
  an elaboration of "are essential"
  some requirements are more important than others
  in practice, some requirements conflict, but priority specifies direction

- are validated
  requirements are checked
  feasible: done a feasibility analysis
  unambiguous: gone through whole document and checked for ambiguity
  validated: we have to validate the validation process


Types of Requirements
----------------------

(A) funcitonal
    what the software does
    behavior of software
    get support from customers about funcitonal requirements

(B) nonfunctional
    other constraints on system that are less obvious because they do not
    initially seem to have anything to do with what software does
      security
      reliability
      performance

(A) user
    imposed on system by end-users of application
    will be able to look at user applicaiton and verify

(B) system
    more detailed
    more peopled are affected here
    audience is people that want to make sure system work
      developer
      operation staff
      finance
      managers


Phases of Requirements Development
-----------------------------------

(1) inception

    some things may sound obvious but are easily done incorrectly or not done
    
    (a) identify stakeholders & their viewpoints
        stakeholders may not want to talk to you
          e.g. prisoners in prison
        have to indentify everyone who have something to do with the project
    
    (b) find agreements & disagreements
        get a good feeling on everybody who are using the system
        may have completely different opinions between departments

    (c) break the ice by asking "dumb questions"
        context free questions
        indicate that you don't understand the field
        need humility
        ask "dumb questions":
          about goals and benefits (need to know why)
            "how are you going to make money with this?"
          about the problem
          about communication activity itself
            "did I ask all questions?"
            "are there any questions I have left out?"

(2) discovery/elicitation

    (a) use a well-defined procedure
        - have meetings with agendas & prepare for the meetings
          specialized training -> requirement facilitators (bridge gaps)
        - define problems, pieces of solutions, in user-oriented way
        - write everything down
        - iterate -> multiple meetings
          come up with draft document

    (b) produce
        - scope of requirement
          specify boundary of what to do and what not to do
        - feasibility analysis
          show that requirement is feasible in document
        - justificaiton of need
          why the requirement is needed
        - stakeholder list
          characterization of stakeholders & their viewpoints
        - environment characteristics
          what the system will operate in
          where the system will be running
        - use cases
          little scenarios of where the system will be used
        - constraints
          any sort of extra high-level constraints that are not obvious
        - prototypes
          actually write some code as part of requirements discovery
          may build end-to-end prototypes
          tend to justify feasibility
          "initial testing"

    (c) software requirements document (IEEE standard for requirements)
        contains
          - glossary
            standard nomenclature for problem
          - user requirements
            "normal" requirements
          - high-level system architecture
            document understanding of system model
          - system requirements
            stated in terms of high-level system architecture
          - system models
          - system evolution
            potential changes to the requirements

(3) negotiation

    come up with too many requirements and can't satisfy
    ideally they are prioritized but practically not that easy
    so we have to negotiate with clients

    - want win-win situation
    - key role of written requirements

(4) validation

    list of things we want out of requirements
    check consistency, completeness, etc.

    via. reviews
         prototypes (little programs to test)
         test cases


==============
Apr. 11, 2016
==============

test driven development
buggy spec, if we explore all possible test cases, we can fill in the spec
test debug the spec before writing the code
it is simpler to write tests than writing code
now we can find the bugs in our spec faster

do you use test driven development?
we don't always practice what we preach. - Paul Eggert, Ph.D

if we have real-time constraints, this needs plan driven development
safety systems also requires plan driven development

the development team gets bigger and more parts of the software are not under
your control, and you can't continuously integrate.


goals of software engineering
------------------------------
(1) understand your problem
    much of the software engineering activity is devoted to finding the
    problem that we are trying to solve, which is easiest to get wrong

(2) design is crucial
    design better be there when we are done
    we should know how the software was designed

(3) quality
    software should always be high-quality

(4) maintainability
    software has to be something that we can fix, improve, refactor

(5) work across a lot of domains
    shouldn't be good for just one thing (web, realtime, embedded, system apps)


software engineering principles (Hooker)
-----------------------------------------
(1) provide value to users
    not always obvious

(2) keep is simple stupid (KISS)
    when in doubt, use the simpler approach
    keep code as simple as possible

(3) have an architectural vision
    don't just look at little picture

(4) plan to get hit by a bus
    do not assume that your software project will have you on it
    other peoples may take over it
    somebody else may be maintaining your project
    if it's important, always write it down
    be ready to be replaced

(5) be ready to change
    designing and building software should not be like building the pyramid
    it should be able to mutated

(6) plan for reuse
    when you build your code, assume that it will be successful and you
    or other people will reuse the current code
    write code that can be reused in other systems

(7) THINK before doing
    don't just code because it feels good to type keystrokes
    think before you build the code, before it's too late

Sommerville likes 1,4,6, and

(8) worry about dependability and performance
    obvious yet important
    when you worry about dependability and performance, you are bringing to
    the table software engineering strength


Developers             Managers
------------------------------------------------------
I wanna code           ensure it does what user wants
McConnell              Sommerville

programming
textbooks
S.E. theory


software construction
----------------------

        problem definition                 corrective maintenance
        requirements definition
      --------------------------------------------------------------
                                  detailed design

      construction planning          coding          integration

                  unit testing     integration testing
      --------------------------------------------------------------
              software architecture            system testing

(1) get your prerequisites right


Plan to throw it away; you will anyhow - F. Brooks
McConnel disagrees and thinks that we should make code work
software is not authored in the usual way
software is edited (like an encyclopedia)
don't plan to throw the whole thing away


collarborative development
---------------------------
(1) focus on cost-effective defect-detection
    bugs will be the normal way of life
    will spending more time fixing defects than writing code
    reduce # of defects as many as possible

(2) collarborative practices do best on defects resistant to traditional tests
    can you break up the project


pair programming
-----------------
pay 2 people's salaries to write one program
  one programmer K has the keyboard and the house
  one programmer J just kibitzes
    find errors quickly, early when they are cheap to fix
    if we wait to review, the cost goes up
    reduces defect removal tests
    have immediate feedback
    back-and-forth is fast
    requires 2 bus hits

guidelines

(1) match pairs
    makes sure the two people are comfortable around each other

(2) rotate
    switch roles

(3) Keyboard = tactics
    Kibitzer = strategy

(4) don't let the kibitzer relax
    make pair programming sessions short

(5) don't use it for everything
    not all things are suited for pair programming


formal inspection
------------------
gold standard for software review (IBM)

(1) focus on defect detection not correction
    formal inspections are expensive
    hard part is mostly finding bugs
    so focus on hard part

(2) use a checklist to focus reviewers' attention
    use different checklists and measure how well each checklist performs
    checklist will depend on problem domain

(3) reviewers prepare for meetings
    have multiple reviewers for reviewing system
    give code ahead of time to read independently and come up with questions
    in the meeting, combine the reviews, big merge of question list

(4) all participants have roles
    moderator: requires most training, competent to organize reviewers
    scribe: keep track of what is set
    reviewers (2-5): reviews the code
    author: usually doesn't participate, but also nice to have there
    managers are not participants, inefficient

(5) time and efficiency
    100-500 lines/hour
    < 2 hours/meeting
    code reviews are very expensive


code walk-through
------------------
code readign
demos (dog & pony)
"demo or die"


software process
-----------------
the set of heuristics
developers' heads (extreme approach)

(lisp (code))
lisp code in which developers are subroutines
this doesn't work

framework for what goes on in developers' heads
dynamic perspective - phases, in some sequence
  communications (requirements)/planning/modeling/construction/deployment
practice perspective (umbrella activities)
  - quality assurance
  - reviews
  - configuration management (how system/requirements are configured)
  - project tracking (keep track of what's done/not done)


plan driven vs. agile approach


==============
Apr. 13, 2016
==============

different engieers have:
different terminology
different world views on how things work
different terforce
  software engineers want to work software engineers get more jobs

trading systems
nobody is in charge
if one system decides to change, others will have to deal with it

conceptual desing --> procurement --> development


software processes
-------------------

(1) plan driven
    
    (a) waterfall model

        | requirements |
        +--------------+
                
          | architecture |
          |    design    |
          +--------------+

               | component |
               |  design   |
               +-----------+

                     | coding |
                     +--------+

                      | unit testing |
                      +--------------+

                      | integration testing |
                      +---------------------+

                                | system testing |
                                +----------------+

                                  | acceptance testing |
                                  +--------------------+

        finish each part before doing the next part

        have a strict client who knows what they want
        then the waterfall model is suitable
        the requirements won't change
        it is inflexible
        going to spend a lot of time twiddling thumbs and waiting

    (b) incremental waterfall model

        repeated, parallel waterfalls
        before first version completes we start gathering requirements on next
        version to minimize the time to release version 3

    (c) spiral model

        increments "spirally"
        goes in organic way

            
              +---> plan -----> model ---------+
              |                                |
    +-> communication                   code <-+
    |                                     |
    +-----------> deliver <---- test <----+


        intent: each level of spiral is a major rethink such that the previous
                versions doesn't matter too much
                do risk analysis before next spiral
                can revert if necessary

    (d) concurrent development

        break task into subtasks and resolve dependencies to concurrently
        develop on the subtask with multiple waterfalls and merges


(2) agile developemnt
    
    rebellion against plans

    promote: adaptability
             self-organization (team will organize itself to get work done)
             collaboration & communication
             working software (new features) every two weeks

    over: software processes
          software tools
          documentation
          planning

    developer teams need to select the work quantity
                        

XP (eXtreme Programming) framework activities/phases
-----------------------------------------------------
                              +---+ <- customer sets the value <-+
planning => set of stories -> |   |                              |
                              +---+ <- dev team sets cost        |
                                       if > 3 weeks, split       |
                                                                 |
                                                                 |
                                           can do high-value first
                                            can do high-risk first
                                   can make commitment to a series

design => set of class designs -> CRC cards + spike solutions (running code)
                                     |
                       (class responsibility collaborator)

            spike solutions to test out a risky part of solution early

coding => code
          unit tests
          pair programming
          refactoring
          tinderboxes

testing => purely to acceptance testing


XP values
----------
communication - informal, verbal
simplicity - don't over-engineer, code for today
discipline - "courage" to say no to client to keep things simple for goals
feedback - listen to clients, fellow developers, and software
respect - respect for clients, fellow developers, and software

downside of XP (from a plan driven guy)
----------------------------------------
lack of a formal design
lack of a formal requirements
volatile requirements (cause a lot of unnecessary work)

downside of XP (from insider)
------------------------------
1. inertia - fighting
2. refactoring /simplfying
3. prioritization is hard (especially in large organizations)
4. some developers aren't good collaborators
5. some clients aren't good collaborators
6. tinder boxes can't catch everything


system engineering
-------------------
software engineering + everything else

                        hardware
                        networking
                        databases
                        documentation
                        people
                        procedures

* systems nest

figure out how to meld together components and build systems out of systems
have multiple levels of nesting (at least 4 levels, usually 5 levels)

[WORLD VIEW]
  enterprise strategy
  overall goal
  how to survive for the future twenty years

[Domain View]
  business area desing
  interested in making sure students graduate on time

[Element view]
  subsystem to help business to work
  business system design
  build tracking software and hardware to track students through degree

[detailed view]
  correspond to traditional values of software engineering
  construction and integration


system engineering phases
--------------------------
conceptual desing => system vision (feasibility + proposal)
procurement => regulations, competition, budget, buy vs build
development => e.g. waterfall
operation => system in use, bug reports, fix things while system operates
             flexibility + adaptability are key
             assume mistakes will happen & system will evolve


system modeling
----------------
Hatley-Pirbhai model


+------------------------------------+
|           user interface           |
+---------+---------------+----------+
|         |   processing  |          |
|  input  +---------------+  output  |
|         | maintainence  |          |
|         |   self-test   |          |
+---------+---------------+----------+


==============
Apr. 20, 2016
==============

$ top

  PID   CPU   CMD
  ...   ...   ...


describe a solution for the observer problem
---------------------------------------------
when a process changes, how do we notify the top program?
notification of change efficiently
want to decouble the observers from the doers


AbstractSubject             AbstractObserver
  addObserver()               notify()
  removeObserver()
  notify() {
    for o in observers:
      o.notify()
  }

ConcreteSubject             ConcreteObserver
  getState()                  State

can have serveral observers observing one subject


what are Gang of Four of design problem
----------------------------------------
name
description of problem
description of solution
consequence (pros & cons) of the pattern

communicate with fellow software developers with short names


what is the Liskov Substitution Principle
------------------------------------------
have a parent class P and child classes C1 C2 C3
should be able to substitute C2 for C1 and the program should work the same

  if (p instanceOf(C3))
    print("got a C3!");

this violates the Liskov Substitution Principle


accidents vs. essence
----------------------
core of design is essence
want to keep essence small as possible
want as few accidents as possible


call-and-return architectural style

  subroutine calls
  1 instruction pointer
  more tightly coupled, fits in well with C++, Java

message-passing architectural style

  send message to server, eventually get a respones
  N instruction pointers
  loosely coupled, fits in well with Smalltalk
  usually more advanced and fancy
  trend is going more towards this way
  * should write a programming language on this

repository architecture (DB)

  send data in to database and others can pickup whenever they want

layered architecture

  build applications in terms of layers on top of machine
  each boundary gives abstraction level

  +-----------------------+
  |   Python libraries    |
  +-----------------------+
  |  Python interpreter   |
  +-----------+-----------+
  | OS Kernel | C library |
  +-----------+-----------+
  | machine instructions  |
  +-----------------------+

client-server architecture

  may be attached to DB
  connected to network
  have a client attached to display, keyboard, mouse
  clients make requests to server and get response back
  server is in charge, responsible
  clients can only issue requests

event-processing architecture

                 events
                    +-+-+-+-+-+-+-+-+-+-+ 
  outside world  -> | | | |*|*|*|*|*|*|*|
                    +-+-+-+-+-+-+-+-+-+-+
                                      event queue
  event processing

    for (;;) {
      e = remove_queue();
      handle(e); // this part must be fast
    }            // could do some work, then signal an event!
                 // to handle large events, partition and add to event queue


distributed architecture
-------------------------
+ increased availability & reliability & fault tolerance
  high availability means system is up at most times (0.999 availability)
  failures of individual components don't cause performance degradation
  if one server crashes, system can keep running with other servers

+ scalability via concurrency
  this comes up even in a non-distribute system
  always an issue in all systems
  common impression is that distributed systems will work better with more
  servers, but this is not the case as systems do not always scale

+ openness
  acheived through protocols
  key way to glue together distributed architecture

+ resource sharing
  can support many different kinds of services on the same platform
  machines support many different users simultaneously
  this saves money & resources
  key driver behind distributed architecture

BUT MUST CONSIDER THE FOLLOWING ISSUES

- failure management
  keep track which part of system is not working

- quality of service (QoS)
  how to specify quality of service
    response time
    requests/second

- security
  safeness of system
  
- transparency
  do users know it's distributed?

- how to scale
  geogrpahy, where to put the servers?
  manageability, a million servers -> configure by hand?

- how open, really
  specialized, proprietary protocols


distributed architecture examples
----------------------------------

master-slave

                  master
  -------------------+-------------------
  +-------+ +-------+ +-------+ +-------+ 
  | slave | | slave | | slave | | slave |
  +-------+ +-------+ +-------+ +-------+ 

fat vs. thin client
 
  fat clients contain lots of state, code, processing
    less server load

  thin clients have little state (stateless), code, processing (may have cache)
    makes it easier to run on different platforms
    makes app size smaller
    security gets better since most of computation is done on server


multi-tiered-client server
  
  layered architectur applied to client-server

  browser
   |
  load balance
   |       |
  cache  cache
   |       |
  application server
       |
  database server


peer-to-peer (P2P)

  internet originally designed that there wouldn't be client or server
  "clients" only (peers)
  run mostly because peers need to interchange information with each other
  without the need for central server (control catalog) to manage them
  can have helpers (semi-centralized architecture)
  security is a problem, trust can be issues


software as a service (SaaS)

  applications on servers controlled by other organizations
  how to glue together lost s of little services
  outside your control
  rely on other services to get your service to work, what if it goes down?


management + architecture
--------------------------
- buy vs. build (any architecture)
- change management
- risk identification
- feasibility analysis
- quality requirements ("over-engineering")


construction decisions
-----------------------
- programming language
  should have at command many different different languages
  different languages are meant for different work

- programming conventions
  hard to change after initial coding
    
    $ foo --version  # should print version and exit
  
  can control this more easily than the language

- programming tools
  IDE (Eclipse)


deisgn
-------
history of software design
  modular program       1950s
  top-down development  1960s
  structured programming ("goto-less programming")
    sequencing:  s;s;
        choice:  if, case
          loop:  while

  Goto considered harmful, E.W. Dijkstra (1967)
  first mentioned by D.ValSchorre (1962)


==============
Apr. 25, 2016
==============

design
-------
design is a heuristic process, not an algorithm
heuristic: often works but sometimes doesn't, never works first time
we should always have to iterate
"wicked problem"
you don't know statement of problem until you've solved most of it

managing complexity, both essential and accidental
keep both to a minimum to get it work


Emacs bug
----------
C-x 8 RET LATIN SMALL LETTER A WITH ACUTE RET
C-x 8 RET 201C RET

but what about BED, which is "bed" and also a valid hexadecimal number
had to find the solution first before Eggert figured out the problem


important design concepts
--------------------------
(1) aspects
    if you have something of a concern about the design scattered all over code
      memory leaks, allocating memory all over the place
      cache control
      user authentication
      internationalization

(2) modularity
    redo your process or your software or both so that you can isolate these
    aspects/concerns into a small set of modules
    suppose we have 1 line of code/module, then code can;t be understandable
    should pick appropriate size for a module

(3) information hiding
    modules should not see each others' information
    ensures functional independence

(4) abstraction
    build higher-level layers with lower-level layers

(5) refinement
    = anti-abstraction

(6) patterns
    common refinement methods

(7) refactoring
    you messed up the modularity, fix it 


design patterns
----------------
high level informal relationship among
  context -> problem + solution <- design force

e.g. factory method pattern
     context: lots of related classes need to create objects
              not necessary the same classes
     problem: standard framework to let each class decide on its own what
              object to create (anytime)
    solution: static method of a class C, returns C
              but actual object may be a subclass of C
design force: creation via inheritance
              relatively simple; often evolves into fancier pattern
              perhaps evolve into protocol pattern (prototype for delegation)

              "hash-consing"
              (hash-cons a b)
              Java, C++ doesn't support this


categories of design patterns
------------------------------
(1) creational
    factory, prototype, singleton, abstract factory

(2) structural
    integrate existing into larger structures
    container, adaptor, pipes & filters

(3) behavorial
    communication & responsibility
    visitor, event listener, interpreter, model view controller (MVC)

    model: entity, "business classes", modeling what's in user's head
    view: boundary, manages how to present business to users (UI components)
    controller: glues together model + view, manages units of work


class + interface issue
------------------------
* beware erosion of abstraction
  can often occur when cost of refactoring is too high
  may be in environment where you have to talk to boss to add class

* beware if
    your class name is a verb
      has only actions
    your class has no methods (structs in C++)
      no actions
    your class does everything
      not taking classes seriously

class design suspicions
------------------------
* be supicious if you see:
    repeated code in subclasses
    base classes with just one subclass
    base classes with > 10 subclasses
    overriding methods that do less than what parent does
    more than 7 levels of inheritance
    multiple inheritance


=============
May. 4, 2016
=============

validation tests whether code matches requirements
  may be hard in practice because of communication problems
verification tests whether system works correctly

configuration management
-------------------------
baseline
  there can be many baseline versions
  may have many components, each comes in a version
  have to pick version for each component
  this is a baseline

codeline
  line of development of individual components
  make sure it is reliable so we can build future systems on it
  codelines aren't actually 'lines',
  but rather acyclic graphs because of branching

version control
----------------
not just code but also all aspects for program
  requirements
  tests
this is often broken by developers

pessimistic     clashes will be bad if two people work on same module
                involves locking to avoid race conditions
                works better with few developers & many modules

optimistic      let two people edit same module, it probably works
                if collisions happen, we do merging
                do not avoid races, but can merge changes to resolve races
                works better with many developers & few modules

centralized     one repository, must change this repository
                change does not exist until you change central repository
                database-oriented
                used by CVS ...

distributed     no central repository
                each developer has their copy of repository
                copies are not necessary in sync with each other
                used by git
                problems in this approach
                  copies are not synched, merging is needed to synchronize
                  the patch becomes your programming element
                  what about patches for patches

git log timestamps are not in time-date order
property of being distributed and de-centralized
can import patch that was dated earlier than when patch was applied

properties of version control
  isolation
  undo/revert
  update (apply patch)
  logs
  backups - are key! test them!

system building
----------------
development platform (record this in version control)
build
target

automation is key
shouldn't require many by-hand building


automating builds
------------------
sh - Lisp - chef
  series of commands to execute
  special case of 'make'
  this is easier to debug though (conventional)

make [-j8]
  dependencies
  directed acyclic graph, explore the graph in parallel
  different outputs every time we build

* project specific

autoconf
  configure.ac (100 lines) --> configure (50000 lines)

automake
  Makefile.am (100 lines) --> Makefile (10000 lines)


testing
--------
testing is unnatural!

goal - success: find bugs!

you typically cannot use tests to prove absence of errors
exhaustive testing only works in small cases

  bool not (bool b) { return !b; }
  int add (int a, int b) { return a+b; }

testing itself does not improve software
it only exposes weaknesses

tempting to under-test

we should test everything!
  code
  specs
  design
  tests [!]

testing is a strategy that you can apply to everything

test-first programming
when to test
  late
  early
  often/always

test driven development (TDD)
  + unit testing
  + converage
  + don't need debugger! (GDB) (some truth to this)
    small changes -> unworking program (easy to find bug)
  + improves documentation
    (1) the test case are the documentation!
    (2) the act of writing down tests tells you what to write in documentation

  - doesn't scale well
  - doesn't work for graphical user interfaces (GUI)
  - doesn't work well for non-deterministic programs
    TDD originally was designed for single-core machine programs
    coming from underlying system, multi-core races
    GUI can be categorized as non-deterministic

test tools
-----------
test data generators
  exist to provide test data for other programs

project-specific scaffolding
  take down after building is built
  supply tests
  build the tester to generate tests

coverage monitor
  $ gcov on SEASnet
  run you program and will show how many times each line of code got executed

platform monitors
  change platform in simple/complex way and see if it passes the same tests
  $ gcc -m32 (generate code for x86 instead of x86-64)

records + logs
  log all tests you run
  keeps a test database that keeps track of all passed/unpassed test
  along with all its parameters and return values


IEEE standard terminology (withdrawn)
--------------------------------------
error      mistake that developers make in their heads
fault      manifestation of error, mistake in the code due to error
failure    fault gets triggered in production and user sees it

error -> fault -> failure
error <- fault <- failure (debugging process)


=============
May. 9, 2016
=============

Should be only when project should be controlled

consistency
honesty
inclusion
respect

project management danger signs
--------------------------------
if you see such danger signs, it may be time for you to leave

* managers and developers avoid best practices
  you know you should do test-first development but people don't want to test
  if there is a general tendency to avoid this, then there is a problem

* sponsorship was lost or never present
  should have backing for this project (inside or outside)
  but sponsor ran out of money or person left the company

* project lacks people who have right skills
  database administrators are working on user interface redesign

* users don't want the software
  annoying software (ads, security software)

* business needs change
  needs changed completely
  idea for funding is no longer supported
  different division argue with each other
  VA Linux (huge boost on first day)

* unrealistic deadlines
  promised that software has to work by deadline

* chosen technology changes
  Android -> iOS

* changes are managed poorly
  ship out new release but forgot to inform customers about changes

* product scope isn't defined
  trying to nail down requirements but haven't figured out whether a
  particular feature belongs to this project or another
  take fuzzy area and figure out sharp line for project

* developers don't understand the customer needs
  writing code, given spec, but don't get why it's there
  think you understand customer need but actually don't

solution elements for software project management
--------------------------------------------------
(1) people

    good staff + good environment
    big enough screens in work station
    fit dev roles to personalities
      - outgoing (love people!)
        talk to customers, negotiate
        manage a project
        have the best correlation with software quality
        people skills are important in building high quality software
      - task oriented (love to program/building stuff!)
      - self oriented (what's in it for me?)
      - neuroticism (how well am I doing?)
      - openness (open to new ideas)
      - argreeableness (how like to agree with others)
        -> job satisfaction
      - conscientiousness (treat tasks seriously)
        -> job satisfaction
      - autonomy
      - meterdependency
      - conflict
    provide motivation, coordination, organization into teams
      toxic teams (weakest link dominates)
      jelled teams (people working together, strong links fill in weak links)
    
    people have different productivities
    order of magnitude difference in productivity
      5:1   ratio, even in large teams
      25:1  ratio for individuals

    Pareto principle (80-20 rule)
      have 80% contribution from 20% developers
      hire the 20% of the developers
      find the motivation the other 80% need

    Maslow motivation hierarchy
    ----------------------------
       self-realization
         esteem needs
         social needs
         safety needs

      safety needs      "do better or you're fired"
                        simple, crude, hopefully not needed
                        not that effective
                          get worried, apply funny tricks to seem to do better

      social needs      social networking, likes meetings
                        we have cities so people can meet with each other

      esteem needs      recognition by peers that you're doing good work
                        get the corner office, better pay, awards, nice parking

      self-realization  self-help, responsibility
                        realize that they can develop by themselves

(2) product

    * bound the scope
      huge part of product management
      draw line between product and non-product
    
    * decompose the problem into subproblems
      draw line between subproducts

(3) process

    organize and control by which your software is being developed
      easier than people management

    * select appropriate process model
      don't choose agile method for air-traffic control
    
    * adapt the generic model to specific environment + projects
    
    * WWWWWHH (Boehm), also W^5HH
      who  what  when  where  why  how  how much
      if these aren't answered then you don't know how process works

(4) product

    * understand the problem
      get the right team
      set realistic and clear objectives/goals

    * minimize turnovers
      let the team do the right thing
        focus on bottom-up process management
      emphasize quality
        start this from first day and not at the end

    * measure progress
      need to know what you're doing and how well you're doing it
      change management
      metrics

    * keep it simple (KISS)
      too easy to complicate things in software
      avoid risk
        simplicity to avoid risk
      focus on complicated/risky areas

    * review what went wrong/right
      don't just fire the project and forget!
      make it better next time

scaling issues
---------------
O(N^2) communication overhead
  as project scales, things working in small project starts failing

probability that a random chosen programmer in the US
will be working in a project of this size

  1-3: 5%
 4-10: 15%
11-25: 15%
26-50: 15%
  50+: 50%

productivity |  \
  kLOC/year  |   `
             |     `
             |       `
             |          `
             |              -
             |                  -
             |
             |
             +-----------------------------
            project size (kLOC) (on log scale)


risk management
----------------
~= estimating variance in project cost

  how to estimate variance?
  --------------------------
  risk table

  risky event                probability P        impact I (qualitative)
  ------------------------------------------------------------------------
  lead developer leaves      0.05
  stakeholder vanishes
  over AWS auota


  impact on qualitative scale
  1. catastrophic
  2. critical
  3. marginal
  4. negligible

  if impact is a cost then we can compute  (P*I)

system testing
---------------
requirement most planning
  harder to change than simple software testing

recovery testing
  for a fault-tolerant system or highly-available system
  make random components fail

security testing
  get penetration teams to try to break into it
    social engineering is the best way to break into system

stress/performance testing
  put it under large load to make sure it behaves correctly
  best done at entire system level
  need proper instrumentation


==============
May. 11, 2016
==============

A * SIZE^B * M
---------------

B: on a scale of [0,5]
add these together, divide by 100, then add 1.1

risk analysis?
development flexibility
preceentedness
team cohesion
process maturity


M: on scale of [1,6]

personnel capability
personnel experience
reuse required
platform difficulty
schedule
support facilities


project planning
-----------------
(1) resource allocation
    have to give resources to a project to get it work
    this is 'people' in a software project
    large company: involve drafting people to get the job done
    small company: use all you have 

(2) scheduling
    when to do what
    as it scales, it gets complex
    unrealistic schedules
      are the project manager's faults
      although tempting to come up with schedule to make customer happy
      learn to resist the unrealistic schedules
      avoid these schedules by negotiating with the customer
      cost models are what we use in negotiations
      learn to redo cost model as the project goes on

(3) cost estimation
    resource allocation + scheduling = cost estimation
    in practice, project planning is rarely disciplined
    it is a interwined consideration
    order of the 3 will not be the same
    may have cost then determine resource + schedule

typical components of a development plan
-----------------------------------------
(1) team organization
    who will work on project and how they will collaborate

(2) risk analysis
    come up with idea on which parts of project are risky

(3) resource requirements
    not just software but also hardware and networking, etc

(4) work breakdown
    unless you have simple project, you have to split up the work
    among developers to do it together
    come up with tasks, milestones, deliverables

(5) schedule

(6) reporting mechanism
    usually forgotten
    crucial to keep track of what work has been done
                             what problems to worry about

hierarchical
  probably the most efficient way to organize software development
  not always needed for small projects

synchronous
  have a lot of people working in parallel
  glue it together in the end and it works
  minimize effort coordinating
  maximize effort getting work done
  has problem with scaling

agile
  starts up synchronous
  then teams self-organize into small hierarchical trees

major issues in a organization
-------------------------------
lines of communication
  among whom?
  email? IRC?
  don't overuse communication
  be efficient in communicating

selecting members
  pick good members for team
  have complementary personalities
  technical competence
  interviewing skills are essential

risk assessment
----------------
need to keep doing as project moves on

* preliminary
  done during requirements gathering
  haven't decided on implementation
  have to do this to know whether to commit to project
  most important to get right

* life-cycle
  done during system development
  know the implementation but don't know the usage fully
  can predict how the software will be used

* operational
  done during production
  software is run with real users
  goal is to resond to production issues
  quick response to issues as they arise

risk categories
----------------
instead of looking at how the risks are going to hit you
look at where risks are coming from

* business
  may be driven out of business by large companies
    Google competes!

* product
  something goes wrong inside software you've written
    garbage collector doesn't scale

* project
  have nothing to do with actual product you're building
    leading developer leaves

risks can overlap although we may think they're independent

sample resource issues
-----------------------
* buy or build?
  should you reuse software or simply build it yourself
  major issue

* inhouse or outsource?
  write it in your own team or outsource it to other teams

* different combinations of the two above
  20 projects -> 2^20 combinations
  how to prune intelligently

deining your tasks
-------------------
class-based
package-based

tasks nest
tasks have dependencies

dependency graph
we can generate a schedule with this graph

critical path analysis
scheduling time -> Gantt chart

when you're late
-----------------
* add resources to project
* add time (delay due date)
* decrease scope

how to price a software project
--------------------------------

C    costs (usually unknown)
P    profit
-----------------------------
C+P  done

we typically guess the cost or adjust the software to match our budget
adjust software to match budget (relies on trust)

general rules for project estimation
-------------------------------------
average large project is 1 year late and 100% over budget

(1) keep + use records of previous projects
(2) use several methods, and cross-check
(3) assume things will go wrong during development
(4) if possible, develop + estimate incrementally

factors affecting cost
-----------------------
(1) size
      $ wc # number of lines
    length of API
    helpful to estimate size before writing the code
    count statements instead of comments
      ;;;;;;;; is totally valid in C

(2) complexity

(3) requirements analyst capability
    requirements analysis is among the hardest parts of software analysis

(4) prgrammer capability

(5) CPU time / storage constraints
    typically bites during embedded application

(6) personnel turnover
    the larger the project, the more likely this is going to happen

(7) platform variability
    affect cost model quite a bit

(8) team experience
    application area
    language and tools
    production platform

(9) use of software tools
    do we have good static tools that will help find bugs before runtime

(10) location / communication

(11) motivation


* Putnam Norden Rayleigh (PNR) curve
























