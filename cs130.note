
Computer Science 130 - Software Engineering

http://web.cs.ucla.edu/classes/spring16/cs130

35%    final exam (open book/notes)
15%    midterm (April 27) (open book/notes)
40%    project
2.5%   requirements homework
7.5%   quizzes (closed book)

June 5 drop-dead date, last day of instruction


Paul Eggert background

  student at UCLA
  did not take software engineering because field did not exist
  became faculty for 3 years and got bored
  left university and started company -> crashed in 5 years
  worked for second largest computer company in the world (Unisys, power of^2)
  another startup -> 12 years (< 50 employees)
  UCLA (after that)

  back-and-forth between academia and industry

==============
Mar. 28, 2016
==============

1. real-world-ish project

   build code that somebody really wants and does not have before
   ideally it should have a client with requirements
   interact with client and produce what client wants

   outside clients, on/off campus, they will not know about software
   ------------------------------------------------------------------
   - IBM
   - Aerospace
   - Anderson School of UCLA
   - Psychology Department
   - Calthorp School

   work in teams of 5, 2-3 teams/client
   -------------------------------------
   - cooperating, where two teams work on different parts of project and
     integrate the whole project in the end
   - competing, where different teams take different approaches to the same
     project

  student projects are also welcome
  ----------------------------------

  project open-source only, typically BSD, GNU, Apache, MIT licensed
  -------------------------------------------------------------------

2. engineering process and practice (higher-level)

   how software engineering works
   almost social-science
   how engineers work with/against each other to build something that works

   how this process works, or doesn't work

   instead of dealing with software, deal with the methods and ways of
   developing the software

3. construction (lower-level)

   know program you want to build, what are the methods and best practices for
   building this piece of software

   actual construction details of software
   ----------------------------------------
   - testing & debugging
   - modularization techniques

   may seem obvious but are actually not
   may be confusing and have pitfalls

   learn not to obvious things in 'obvious' things


What is of software and why is it different?
---------------------------------------------
- set of rules a computer follows
  
  microcode in commercial chips is not included as software
    hardwired into the CPU
    cannot be changed at all

  firmware is not software either
    halfway between hardware & software
    code that is tightly bound with hardware
    low-level code + hard to change (ROM)

    we can write very low-level code
    this is software but very low-level code
    calculate a random number

      // x86-64 machine, includes instruction
      // return a random number 0 ~ 2^63 - 1
      // this works only on x86-64 Hasweller machine
      long randnum(void) { asm ("RDRAND"); }


  1. software is easy to change
     ---------------------------
     mutability of instructions
     mutability brings forth engineering problems that make software hard

  2. it's not manufactured in the traditional sense
     -----------------------------------------------
     don't have to worry about manufacturing
     - type 'cp' or 'scp' to copy program and ship

  3. it doesn't wear out
     --------------------
     don't have to worry about parts wearing out
     parts fail -> lubrication/replacement/repair
     can run program any number of times you want

     hardware failure rate (bathtub curve)
       break-in period: not manufactured correctly
       wear out: finally breaks down because of time

     software failure rate (spikey bathtub curve)
       increases failure rate with each new release
       decreases failure rate as bugs get fixed
       failure rate increases overall as software gets bigger

  4. there are no spare parts
     -------------------------
     if program crashes, replacing with same new copy will not fix it
     
     - maybe revert to previous version
       gzip 1.7 on Solaris 10 with Oracle cc x86-64 crashes
         configuration uses match.S  <-- machine code does not run, dumps core
       gzip 1.6 on this platform (can be considered spare part)

     - maybe substitute a different implementation
       use pigz instead
         different implementation of gzip compression algorithm
         runs in parallel


What is software engineering?
------------------------------
1960s: software was out of control
       "software crisis": too many bugs in software
       need discipline for software development

F.L. Baver (1969): the [establishment] and [use] of [sound] [engineering]
                   principles in order to obtain [economically] software that
                   is [reliable] and works [efficiently] on [real machines]

this definition did not include teamwork


Shellshock Bug (reported 2014-09-24)
-------------------------------------
bug in bash

  $ cp = '(){ ... }'
  $ export cp

this treated 'cp' as a function definition
then running 'cp a b' would run the function above
this bug had been in bash for 20 years

San Diego Union (reported 1994-04-27)
--------------------------------------
DMV spent $44 million on software that doesn't work and will never work
nobody was responsible

wanted to convert circa 1960 database to modern relational database
had bottleneck that could not handle the load that the DMV threw at it


* Most software projects fail.


Alternatives to software engineering
-------------------------------------
* add people to a late project
  often not a good idea

* outsourcing
  outsource to another group
  hire contractor, and let somebody else do the job
  sometimes works, but 'distance' will be a problem
  lose control of the software (intellectual rights access)

* vague objectives and requirements constantly changing
  "agile development"
  sometimes works but often doesn't

* fire and forget
  get some code out the door by the stated deadline and never touching again

* code is all there is
  don't bother to write documentation becuase it is a hassle and probably
  doesn't match the code either

* voluminous PPM (Policies & Procedures Manuals)
  software development process that documents everything
  software development process takes much longer than it may take
  good for developing reliable software
  and proving that it is reliable


software engineering           vs.           computer science
----------------------------------------------------------------------
practical problems of                        theory & methods that
 producing software                            underly programs

software engineering           vs.           system engineering
----------------------------------------------------------------------
just software plus                       software, hardware, firmware 
 human interface                                process design
                                                    policy


==============
Mar. 30, 2016
==============

Presentations for projects

1. The Aerospace Corporation (Mustafa Alammar)
   Enterprise Information Systems/AppDev

   Aerocube-7

   Mission Assurance
     making sure rockets launch successfully
     consulting company
     helping SpaceX certify rockets
     launch national satellites

     SpaceX, NRO Satellites, U.S. Space Systems, Cyber Security

   R&D
     space systems
     spectral imaging
     small satellites (micro/pico-satellites)

   VAEROS
     more on civil and commercial customers, NASA and SpaceX
     'container inspection tests at Port of Oakland'
     modeling and simulation
     CI security

   technology used: SQL, PHP, Java, HTML, CSS, JavaScript, AngularJS


 Last year: orbital debris tracking

   Center for Orbital Reentry & Depris Studies (CORDS)
     tracking orbital debris
     visualizing and tracking for all
   
   Junk Explorer
     MySQL
     Bootstrap
     Google Earth/Maps
     www.space-track.org
     Digital Ocean


 This year: cyber security

   http://map.norsecorp.com/

   develop site and server security intrusion detection, monitoring and more
   develop plugins, applications, algorithms, or systems to detect and
     defend against security vulnerabilities on pubilc-facing websites

   Requirements
   
   (1) makes a measurable or testable difference in improving site security
         DDoS mitigation of security vulnerabilities detected or eliminated
         span detection/removal
         success rate of 'hack' removal

   (2) easy to use or install
         if (application.needsConstantAttention == true)
           application.uninstall

   (3) reliable
         if (application.falsePositiveRate > 0.1)
           application.uninstall()       

   (4) leverage existing solutions
    
        APIs
          Akismet
          ReCAPTCHA
          CLOUDFARE
      
        fill in the gaps
          usability
          effectiveness
          ease of installation
          cost
          compatibility
      
        remember the user


2. Connexity

   tech-driven marketing solutions company
   connect reteailers to customers they care about

   used to be called Shopzilla

   Project: Publisher Challenge
   -----------------------------
   use the Shopzilla Catalog API to build own shopping website
   expose shopping content
   develop back-end and front-end components of shopping site
   compete for most redirects and 'revenue'

   Challenges
   -----------
   API integration
   what data should your website use
   determining what additional information would be useful
   completing the flow-API -> backend logic -> front-end display

   Technologies
   -------------
   enterprise level technologies
     Java
     Spring MVC
   UI component
   interaction with API

   Logistics
   ----------
   mentorship from former cs130 students
   direct experience with enterprise level engineering practices
   setup guidelines
   onsite development workshops
   Git/Github
   various methods of communication between teams and Connexity


3. International Business Machines (IBM)

   Project Lead: Gergana Markova   gmarkova@us.ibm.com
   Dean Okamura    dean.cs130@gmail.com
   Michael Stein   mastein@us.ibm.com
   Neil Sahota     nsahota@us.ibm.com

   team project planning
   collaboration, networking
   rapid decision making
   open source community involvement
   agile development
   globalization awareness
   design thinking and user experience
   reserach and resources evaluation

   Cool cs130 IBM projects
   ------------------------
   Barcode Wallet
     -> Apple Pay
   Volunteer snack delivery service
     -> Uber
   Jazz festival
   Tutoring website enhancements


4. Anderson School at UCLA
   
   cyber security for small businesses
   

=============
Apr. 1, 2016
=============

Jae Lee
TA OH: 2-4 PM Wed.

name
skills/resume
top 5 project preferences


requirements gathering exercies
--------------------------------
Paul Eggert, senior FAA admin
hire company with software developers to solve problem with software
probably some hardware

problem: drones
make country air space safe, aircraft traffic
worst: plane crash, loss of life
dealing with drones because they are threat to air traffic safety
report of drones within few meters of commercial aircraft
afraid of crash and people get killed

software solution to part of this problem
manage drone issues
in realitiy drones can be small to much larger unmanned aircraft
want system to keep track of all of this stuff
not too worried about large drones, who have lots of money
most worried about small drones

require drones operators to register their drones on website
pay $5 for registration
not every drone use has registered
fine of operating drone without licence

should be able to grab drone serial number and find owner

have website with serial number with names and everything else
really unorganized about this
data sitting in server, which is not very useful

senario: firefighters putting out fires in mountains, but spotted drones near
facilities, so couldn't fly
want to find the owner of the drone

want software that gives information to law enforcement facilities when
dealing with illegal drones

information have to be private
general public cannot find owner through serial number

mostly concerned with airport safety but firefighting case is also important
fire department can get FAA to establish a temporary no-fly zone

make data available to LAPD if needed
real goal to prevent drones from causing safety problems

may want total control over drones in the future
e.g. button that can safely land the drones and accessible to police

should have audit trail for all accesses to data and entering of data

should have images that can be matched to low quality images taken by pilots
could try to identify the signal controlling the drone

                  Wi-Fi
cell phone   --------------->   controller  --------------->  drone
                encrypted                      encrypted

Wi-Fi (WEP) is easily crackable
security on drones and controllers is terrible

drones cannot be identified by radar
want to add transponder so that if we point radar at them, we get signal back
want transponder in database for indentification
drone makers reluctant to add transponder due to weight and size
users will take transponder down
if this happens, will like to track down owner and quesiton why turned it off
cannot take down the drones, which are hard

will also work with custom-made drones
such as, must install transponder

priority: people goofing off flying into airports just to fool around

should not lose data due to disk crashes

new owner should register if bought from previous owner

how to get serial number if we do not take drone down
transponders come with serial numbers

2-3 million dollars
time frame 18 months

want this to work on police laptops and cellphones


=============
Apr. 4, 2016
=============

5. Calthorp School (Principal)
   
   standardized testingw as a big deal
   stayed in good standing

   from public school system to independent schools (private schools)

   have to ability to choose
   resources & autonomy

   schools have collected huge amounts of data
   but schools are terrible at analyzing the data
   find patterns

   data -> analysis -> trends -> areas of exploration -> questions
   -> hypotheses -> confimation/invalidation


6. Department of Psychology

   web-based tool to find career he/she is passionate about

   research team of undergrad students at UCLA
   career websites focus on interest... but what about passion?

   Pandora-like algorithm
   like or dislike

   world of work to classify


7. Beehive

   make social media analytics available to all


8. Airbnb for restaurants


9. Connoisseur

   ineffeciencies in finding next dining experience


10. Sugar-Watch
     
    glucose monitor
    how it affects the body
    partner with 2 doctors at UCLA Medical Center & Anderson School

    600 billion dollar market

    doctor & patient needs
    real time data on glucose levels


11. Aerospace Coporation

    federally funded research centers
    works in the national interest


=============
Apr. 6, 2016
=============

Why do we need requirements?
-----------------------------
* developers != users
* legal, contract reasons
* reliability/safety is crucial
* security (tricy in practice)

How much work to put into requirements?
How long/big is the requirements document?
-------------------------------------------
it dependes on the project
the more of the above required, the longer it will get


* one of the most common requirements document problem is that customers would
not want to read the long and obvious document because they are specifying
what the customers already know.


Requirement Engineering
------------------------
applying sound engineering principles to come up with requirements documents

                     requirements
    stakeholders <---------+--------> design
                           |
    - everybody who        |
    cares about            |
    the software           |
    - users/managers       |
                           |
    system model <---------+

    - in developers' heads


Good Requirements
------------------

- are testable (once system is implemented)
  ideally would want to make it quantifiable
  realistically turn it from something vague to something less vague
  "build a system where the UI is userfriendly"
    this is not testable
    change to something testable
    we could test them on users

- are feasible (in the indented environment)
  make sure requirements are actually doable
  do not make NP-complete requirements

- don't conflict with each other
  conflict are not obvious
  come from different parts of the requirements document
  gathered from different parts of the customer organization
  inconsistent requirements documents arise with conflicting user intentions
  conflicts may not be obvious and may reflect conflicts among users

- are attributed (to specific source)
  can go to any requirement in document and see who is responsible
  each requirement should be attributed to specific source
  should know who to ask if there is a problem in the requirements

- are bounded
  do not want to have requirement that is infinitely hard to satisfy
  should know when the requirements are satisfied
  "as fast as possible"
  do not want software engineers to develop "forever"

- are unambiguous
  ambiguous: so few requirements or so poorly stated so that they can be
             interpreted in many different ways
  should avoid the ambiguity (English is ambiguous)
  need somthing functional

- are essential
  Aristotle: get at heart/core of the story
             find out what really matters
             this is called the "essence"
  good requirements should focus on the essential part of the application
  and not trivial details

- are specified at the user level
  write in natural language that the user understands
  do not write in code-like languages such as Java, C, Shell Script

- match the system's vision
  when you try to change the world with your application, you should know what
  the world looks like after your application

- are prioritized
  an elaboration of "are essential"
  some requirements are more important than others
  in practice, some requirements conflict, but priority specifies direction

- are validated
  requirements are checked
  feasible: done a feasibility analysis
  unambiguous: gone through whole document and checked for ambiguity
  validated: we have to validate the validation process


Types of Requirements
----------------------

(A) funcitonal
    what the software does
    behavior of software
    get support from customers about funcitonal requirements

(B) nonfunctional
    other constraints on system that are less obvious because they do not
    initially seem to have anything to do with what software does
      security
      reliability
      performance

(A) user
    imposed on system by end-users of application
    will be able to look at user applicaiton and verify

(B) system
    more detailed
    more peopled are affected here
    audience is people that want to make sure system work
      developer
      operation staff
      finance
      managers


Phases of Requirements Development
-----------------------------------

(1) inception

    some things may sound obvious but are easily done incorrectly or not done
    
    (a) identify stakeholders & their viewpoints
        stakeholders may not want to talk to you
          e.g. prisoners in prison
        have to indentify everyone who have something to do with the project
    
    (b) find agreements & disagreements
        get a good feeling on everybody who are using the system
        may have completely different opinions between departments

    (c) break the ice by asking "dumb questions"
        context free questions
        indicate that you don't understand the field
        need humility
        ask "dumb questions":
          about goals and benefits (need to know why)
            "how are you going to make money with this?"
          about the problem
          about communication activity itself
            "did I ask all questions?"
            "are there any questions I have left out?"

(2) discovery/elicitation

    (a) use a well-defined procedure
        - have meetings with agendas & prepare for the meetings
          specialized training -> requirement facilitators (bridge gaps)
        - define problems, pieces of solutions, in user-oriented way
        - write everything down
        - iterate -> multiple meetings
          come up with draft document

    (b) produce
        - scope of requirement
          specify boundary of what to do and what not to do
        - feasibility analysis
          show that requirement is feasible in document
        - justificaiton of need
          why the requirement is needed
        - stakeholder list
          characterization of stakeholders & their viewpoints
        - environment characteristics
          what the system will operate in
          where the system will be running
        - use cases
          little scenarios of where the system will be used
        - constraints
          any sort of extra high-level constraints that are not obvious
        - prototypes
          actually write some code as part of requirements discovery
          may build end-to-end prototypes
          tend to justify feasibility
          "initial testing"

    (c) software requirements document (IEEE standard for requirements)
        contains
          - glossary
            standard nomenclature for problem
          - user requirements
            "normal" requirements
          - high-level system architecture
            document understanding of system model
          - system requirements
            stated in terms of high-level system architecture
          - system models
          - system evolution
            potential changes to the requirements

(3) negotiation

    come up with too many requirements and can't satisfy
    ideally they are prioritized but practically not that easy
    so we have to negotiate with clients

    - want win-win situation
    - key role of written requirements

(4) validation

    list of things we want out of requirements
    check consistency, completeness, etc.

    via. reviews
         prototypes (little programs to test)
         test cases


==============
Apr. 11, 2016
==============

test driven development
buggy spec, if we explore all possible test cases, we can fill in the spec
test debug the spec before writing the code
it is simpler to write tests than writing code
now we can find the bugs in our spec faster

do you use test driven development?
we don't always practice what we preach. - Paul Eggert, Ph.D

if we have real-time constraints, this needs plan driven development
safety systems also requires plan driven development

the development team gets bigger and more parts of the software are not under
your control, and you can't continuously integrate.


goals of software engineering
------------------------------
(1) understand your problem
    much of the software engineering activity is devoted to finding the
    problem that we are trying to solve, which is easiest to get wrong

(2) design is crucial
    design better be there when we are done
    we should know how the software was designed

(3) quality
    software should always be high-quality

(4) maintainability
    software has to be something that we can fix, improve, refactor

(5) work across a lot of domains
    shouldn't be good for just one thing (web, realtime, embedded, system apps)


software engineering principles (Hooker)
-----------------------------------------
(1) provide value to users
    not always obvious

(2) keep is simple stupid (KISS)
    when in doubt, use the simpler approach
    keep code as simple as possible

(3) have an architectural vision
    don't just look at little picture

(4) plan to get hit by a bus
    do not assume that your software project will have you on it
    other peoples may take over it
    somebody else may be maintaining your project
    if it's important, always write it down
    be ready to be replaced

(5) be ready to change
    designing and building software should not be like building the pyramid
    it should be able to mutated

(6) plan for reuse
    when you build your code, assume that it will be successful and you
    or other people will reuse the current code
    write code that can be reused in other systems

(7) THINK before doing
    don't just code because it feels good to type keystrokes
    think before you build the code, before it's too late

Sommerville likes 1,4,6, and

(8) worry about dependability and performance
    obvious yet important
    when you worry about dependability and performance, you are bringing to
    the table software engineering strength


Developers             Managers
------------------------------------------------------
I wanna code           ensure it does what user wants
McConnell              Sommerville

programming
textbooks
S.E. theory


software construction
----------------------

        problem definition                 corrective maintenance
        requirements definition
      --------------------------------------------------------------
                                  detailed design

      construction planning          coding          integration

                  unit testing     integration testing
      --------------------------------------------------------------
              software architecture            system testing

(1) get your prerequisites right


Plan to throw it away; you will anyhow - F. Brooks
McConnel disagrees and thinks that we should make code work
software is not authored in the usual way
software is edited (like an encyclopedia)
don't plan to throw the whole thing away


collarborative development
---------------------------
(1) focus on cost-effective defect-detection
    bugs will be the normal way of life
    will spending more time fixing defects than writing code
    reduce # of defects as many as possible

(2) collarborative practices do best on defects resistant to traditional tests
    can you break up the project


pair programming
-----------------
pay 2 people's salaries to write one program
  one programmer K has the keyboard and the house
  one programmer J just kibitzes
    find errors quickly, early when they are cheap to fix
    if we wait to review, the cost goes up
    reduces defect removal tests
    have immediate feedback
    back-and-forth is fast
    requires 2 bus hits

guidelines

(1) match pairs
    makes sure the two people are comfortable around each other

(2) rotate
    switch roles

(3) Keyboard = tactics
    Kibitzer = strategy

(4) don't let the kibitzer relax
    make pair programming sessions short

(5) don't use it for everything
    not all things are suited for pair programming


formal inspection
------------------
gold standard for software review (IBM)

(1) focus on defect detection not correction
    formal inspections are expensive
    hard part is mostly finding bugs
    so focus on hard part

(2) use a checklist to focus reviewers' attention
    use different checklists and measure how well each checklist performs
    checklist will depend on problem domain

(3) reviewers prepare for meetings
    have multiple reviewers for reviewing system
    give code ahead of time to read independently and come up with questions
    in the meeting, combine the reviews, big merge of question list

(4) all participants have roles
    moderator: requires most training, competent to organize reviewers
    scribe: keep track of what is set
    reviewers (2-5): reviews the code
    author: usually doesn't participate, but also nice to have there
    managers are not participants, inefficient

(5) time and efficiency
    100-500 lines/hour
    < 2 hours/meeting
    code reviews are very expensive


code walk-through
------------------
code readign
demos (dog & pony)
"demo or die"


software process
-----------------
the set of heuristics
developers' heads (extreme approach)

(lisp (code))
lisp code in which developers are subroutines
this doesn't work

framework for what goes on in developers' heads
dynamic perspective - phases, in some sequence
  communications (requirements)/planning/modeling/construction/deployment
practice perspective (umbrella activities)
  - quality assurance
  - reviews
  - configuration management (how system/requirements are configured)
  - project tracking (keep track of what's done/not done)


plan driven vs. agile approach


==============
Apr. 13, 2016
==============

different engieers have:
different terminology
different world views on how things work
different terforce
  software engineers want to work software engineers get more jobs

trading systems
nobody is in charge
if one system decides to change, others will have to deal with it

conceptual desing --> procurement --> development


software processes
-------------------

(1) plan driven
    
    (a) waterfall model

        | requirements |
        +--------------+
                
          | architecture |
          |    design    |
          +--------------+

               | component |
               |  design   |
               +-----------+

                     | coding |
                     +--------+

                      | unit testing |
                      +--------------+

                      | integration testing |
                      +---------------------+

                                | system testing |
                                +----------------+

                                  | acceptance testing |
                                  +--------------------+

        finish each part before doing the next part

        have a strict client who knows what they want
        then the waterfall model is suitable
        the requirements won't change
        it is inflexible
        going to spend a lot of time twiddling thumbs and waiting

    (b) incremental waterfall model

        repeated, parallel waterfalls
        before first version completes we start gathering requirements on next
        version to minimize the time to release version 3

    (c) spiral model

        increments "spirally"
        goes in organic way

            
              +---> plan -----> model ---------+
              |                                |
    +-> communication                   code <-+
    |                                     |
    +-----------> deliver <---- test <----+


        intent: each level of spiral is a major rethink such that the previous
                versions doesn't matter too much
                do risk analysis before next spiral
                can revert if necessary

    (d) concurrent development

        break task into subtasks and resolve dependencies to concurrently
        develop on the subtask with multiple waterfalls and merges


(2) agile developemnt
    
    rebellion against plans

    promote: adaptability
             self-organization (team will organize itself to get work done)
             collaboration & communication
             working software (new features) every two weeks

    over: software processes
          software tools
          documentation
          planning

    developer teams need to select the work quantity
                        

XP (eXtreme Programming) framework activities/phases
-----------------------------------------------------
                              +---+ <- customer sets the value <-+
planning => set of stories -> |   |                              |
                              +---+ <- dev team sets cost        |
                                       if > 3 weeks, split       |
                                                                 |
                                                                 |
                                           can do high-value first
                                            can do high-risk first
                                   can make commitment to a series

design => set of class designs -> CRC cards + spike solutions (running code)
                                     |
                       (class responsibility collaborator)

            spike solutions to test out a risky part of solution early

coding => code
          unit tests
          pair programming
          refactoring
          tinderboxes

testing => purely to acceptance testing


XP values
----------
communication - informal, verbal
simplicity - don't over-engineer, code for today
discipline - "courage" to say no to client to keep things simple for goals
feedback - listen to clients, fellow developers, and software
respect - respect for clients, fellow developers, and software

downside of XP (from a plan driven guy)
----------------------------------------
lack of a formal design
lack of a formal requirements
volatile requirements (cause a lot of unnecessary work)

downside of XP (from insider)
------------------------------
1. inertia - fighting
2. refactoring /simplfying
3. prioritization is hard (especially in large organizations)
4. some developers aren't good collaborators
5. some clients aren't good collaborators
6. tinder boxes can't catch everything


system engineering
-------------------
software engineering + everything else

                        hardware
                        networking
                        databases
                        documentation
                        people
                        procedures

* systems nest

figure out how to meld together components and build systems out of systems
have multiple levels of nesting (at least 4 levels, usually 5 levels)

[WORLD VIEW]
  enterprise strategy
  overall goal
  how to survive for the future twenty years

[Domain View]
  business area desing
  interested in making sure students graduate on time

[Element view]
  subsystem to help business to work
  business system design
  build tracking software and hardware to track students through degree

[detailed view]
  correspond to traditional values of software engineering
  construction and integration


system engineering phases
--------------------------
conceptual desing => system vision (feasibility + proposal)
procurement => regulations, competition, budget, buy vs build
development => e.g. waterfall
operation => system in use, bug reports, fix things while system operates
             flexibility + adaptability are key
             assume mistakes will happen & system will evolve


system modeling
----------------
Hatley-Pirbhai model


+------------------------------------+
|           user interface           |
+---------+---------------+----------+
|         |   processing  |          |
|  input  +---------------+  output  |
|         | maintainence  |          |
|         |   self-test   |          |
+---------+---------------+----------+


==============
Apr. 20, 2016
==============

$ top

  PID   CPU   CMD
  ...   ...   ...


describe a solution for the observer problem
---------------------------------------------
when a process changes, how do we notify the top program?
notification of change efficiently
want to decouble the observers from the doers


AbstractSubject             AbstractObserver
  addObserver()               notify()
  removeObserver()
  notify() {
    for o in observers:
      o.notify()
  }

ConcreteSubject             ConcreteObserver
  getState()                  State

can have serveral observers observing one subject


what are Gang of Four of design problem
----------------------------------------
name
description of problem
description of solution
consequence (pros & cons) of the pattern

communicate with fellow software developers with short names


what is the Liskov Substitution Principle
------------------------------------------
have a parent class P and child classes C1 C2 C3
should be able to substitute C2 for C1 and the program should work the same

  if (p instanceOf(C3))
    print("got a C3!");

this violates the Liskov Substitution Principle


accidents vs. essence
----------------------
core of design is essence
want to keep essence small as possible
want as few accidents as possible


call-and-return architectural style

  subroutine calls
  1 instruction pointer
  more tightly coupled, fits in well with C++, Java

message-passing architectural style

  send message to server, eventually get a respones
  N instruction pointers
  loosely coupled, fits in well with Smalltalk
  usually more advanced and fancy
  trend is going more towards this way
  * should write a programming language on this

repository architecture (DB)

  send data in to database and others can pickup whenever they want

layered architecture

  build applications in terms of layers on top of machine
  each boundary gives abstraction level

  +-----------------------+
  |   Python libraries    |
  +-----------------------+
  |  Python interpreter   |
  +-----------+-----------+
  | OS Kernel | C library |
  +-----------+-----------+
  | machine instructions  |
  +-----------------------+

client-server architecture

  may be attached to DB
  connected to network
  have a client attached to display, keyboard, mouse
  clients make requests to server and get response back
  server is in charge, responsible
  clients can only issue requests

event-processing architecture

                 events
                    +-+-+-+-+-+-+-+-+-+-+ 
  outside world  -> | | | |*|*|*|*|*|*|*|
                    +-+-+-+-+-+-+-+-+-+-+
                                      event queue
  event processing

    for (;;) {
      e = remove_queue();
      handle(e); // this part must be fast
    }            // could do some work, then signal an event!
                 // to handle large events, partition and add to event queue


distributed architecture
-------------------------
+ increased availability & reliability & fault tolerance
  high availability means system is up at most times (0.999 availability)
  failures of individual components don't cause performance degradation
  if one server crashes, system can keep running with other servers

+ scalability via concurrency
  this comes up even in a non-distribute system
  always an issue in all systems
  common impression is that distributed systems will work better with more
  servers, but this is not the case as systems do not always scale

+ openness
  acheived through protocols
  key way to glue together distributed architecture

+ resource sharing
  can support many different kinds of services on the same platform
  machines support many different users simultaneously
  this saves money & resources
  key driver behind distributed architecture

BUT MUST CONSIDER THE FOLLOWING ISSUES

- failure management
  keep track which part of system is not working

- quality of service (QoS)
  how to specify quality of service
    response time
    requests/second

- security
  safeness of system
  
- transparency
  do users know it's distributed?

- how to scale
  geogrpahy, where to put the servers?
  manageability, a million servers -> configure by hand?

- how open, really
  specialized, proprietary protocols


distributed architecture examples
----------------------------------

master-slave

                  master
  -------------------+-------------------
  +-------+ +-------+ +-------+ +-------+ 
  | slave | | slave | | slave | | slave |
  +-------+ +-------+ +-------+ +-------+ 

fat vs. thin client
 
  fat clients contain lots of state, code, processing
    less server load

  thin clients have little state (stateless), code, processing (may have cache)
    makes it easier to run on different platforms
    makes app size smaller
    security gets better since most of computation is done on server


multi-tiered-client server
  
  layered architectur applied to client-server

  browser
   |
  load balance
   |       |
  cache  cache
   |       |
  application server
       |
  database server


peer-to-peer (P2P)

  internet originally designed that there wouldn't be client or server
  "clients" only (peers)
  run mostly because peers need to interchange information with each other
  without the need for central server (control catalog) to manage them
  can have helpers (semi-centralized architecture)
  security is a problem, trust can be issues


software as a service (SaaS)

  applications on servers controlled by other organizations
  how to glue together lost s of little services
  outside your control
  rely on other services to get your service to work, what if it goes down?


management + architecture
--------------------------
- buy vs. build (any architecture)
- change management
- risk identification
- feasibility analysis
- quality requirements ("over-engineering")


construction decisions
-----------------------
- programming language
  should have at command many different different languages
  different languages are meant for different work

- programming conventions
  hard to change after initial coding
    
    $ foo --version  # should print version and exit
  
  can control this more easily than the language

- programming tools
  IDE (Eclipse)


deisgn
-------
history of software design
  modular program       1950s
  top-down development  1960s
  structured programming ("goto-less programming")
    sequencing:  s;s;
        choice:  if, case
          loop:  while

  Goto considered harmful, E.W. Dijkstra (1967)
  first mentioned by D.ValSchorre (1962)


==============
Apr. 25, 2016
==============

design
-------
design is a heuristic process, not an algorithm
heuristic: often works but sometimes doesn't, never works first time
we should always have to iterate
"wicked problem"
you don't know statement of problem until you've solved most of it

managing complexity, both essential and accidental
keep both to a minimum to get it work


Emacs bug
----------
C-x 8 RET LATIN SMALL LETTER A WITH ACUTE RET
C-x 8 RET 201C RET

but what about BED, which is "bed" and also a valid hexadecimal number
had to find the solution first before Eggert figured out the problem


important design concepts
--------------------------
(1) aspects
    if you have something of a concern about the design scattered all over code
      memory leaks, allocating memory all over the place
      cache control
      user authentication
      internationalization

(2) modularity
    redo your process or your software or both so that you can isolate these
    aspects/concerns into a small set of modules
    suppose we have 1 line of code/module, then code can;t be understandable
    should pick appropriate size for a module

(3) information hiding
    modules should not see each others' information
    ensures functional independence

(4) abstraction
    build higher-level layers with lower-level layers

(5) refinement
    = anti-abstraction

(6) patterns
    common refinement methods

(7) refactoring
    you messed up the modularity, fix it 


design patterns
----------------
high level informal relationship among
  context -> problem + solution <- design force

e.g. factory method pattern
     context: lots of related classes need to create objects
              not necessary the same classes
     problem: standard framework to let each class decide on its own what
              object to create (anytime)
    solution: static method of a class C, returns C
              but actual object may be a subclass of C
design force: creation via inheritance
              relatively simple; often evolves into fancier pattern
              perhaps evolve into protocol pattern (prototype for delegation)

              "hash-consing"
              (hash-cons a b)
              Java, C++ doesn't support this


categories of design patterns
------------------------------
(1) creational
    factory, prototype, singleton, abstract factory

(2) structural
    integrate existing into larger structures
    container, adaptor, pipes & filters

(3) behavorial
    communication & responsibility
    visitor, event listener, interpreter, model view controller (MVC)

    model: entity, "business classes", modeling what's in user's head
    view: boundary, manages how to present business to users (UI components)
    controller: glues together model + view, manages units of work


class + interface issue
------------------------
* beware erosion of abstraction
  can often occur when cost of refactoring is too high
  may be in environment where you have to talk to boss to add class

* beware if
    your class name is a verb
      has only actions
    your class has no methods (structs in C++)
      no actions
    your class does everything
      not taking classes seriously

class design suspicions
------------------------
* be supicious if you see:
    repeated code in subclasses
    base classes with just one subclass
    base classes with > 10 subclasses
    overriding methods that do less than what parent does
    more than 7 levels of inheritance
    multiple inheritan



















