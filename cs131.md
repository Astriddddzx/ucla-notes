# CS131: Programming Languages

# Sep. 25, 2015

## CS131 Lab

* Seunghyun Yoo (shyoo1st@cs.ucla.edu)
* Wed 5:30 pm - 6:30 pm, Thu 1:30 pm - 2:30 pm

* Join [Piazza](piazza.com/ucla/fall2015/cs131)

## OCaml

Installation
-------------
* SEASnet: 4.02.3
* Local Machine: ocaml.org

Introduction
-------------
* Functional Programming

```
# let rec fact x = if x <= 1 then 1 else x * fact (x - 1);;
# fact 5;;
-  : int = 120
```

* Using files
  - `# #use 'file-name.ml';;` or `$ ocaml < fact.ml`

* Define Functions

```
# let square x = x * x;;
val square : int -> int = <fun>
# square 3;;
-  : int = 9
```

```
# let add x y = x + y;;
val add : int -> int -> int = <fun>
# add 1 2;;
-  : int = 3
```

```
(cf) # let add (x, y) = x + y;;
val add : int * int -> int = <fun>
```

* If & Match Statement

```
# let max a b = if a > b then a else b;;
val max : 'a -> 'a -> 'a = <fun>
```

```
# let eval_op op v1 v1 =
	match op with
	| "+" -> v1 + v1
	| "-" -> v1 - v2
	| "*" -> v1 * v2
	| _ -> failwith ("undefined");;
```

* List

```
# [ 1; 2; 3 ] ;;
# 1 :: (2 :: (3 :: [])) ;;
# 1 :: 2 :: 3 [] ;;
```

* List Operators

- :: Operator

```
1 :: 2 :: 3 :: []
```

- Appending Lists

```
List.append [1;2;3] [4;5;6];;
[1;2;3] @ [4;5;6];
```

* Extract Data from LIst

```
# let rec sum l = 
	match l with 
	| [] -> 0
	| h :: 5 -> h + sum t;;
# sum [1;2;3];;
# sum [];;
```

* Type

```
type name = typedef;;
type 'a name = typedef;;
```

- Type declarations can be parameterized by type variables

```
# type 'param paired_with_integer = int * 'param;;
# type age type = int;;
# let a: age type = l;;
# type specific_pair = float paired_with_integer;;
# type a' my list = 'a list;;
# type int list = int my list;;
```

* Equal & Identical operator

```
# let a = [ 1; 3 ];;
# let b = [ 1; 3 ];;

# a = b ?
# a == b ?
# a == a ?
```

* Arithmetic Operators

- Must specify type of number explicitly
  * 1 + 0.5;; (not allowed)
  * 1. + 0.5 (not allowed, only for integers)
  * 1. +. 0.5;; (correct)

* Tail Recursion

```
# let rec make_list n = 
	if n = 0
		then []
	else n :: make_list (n-1);;

# let big_list = make_list 10000000;;
Stack overflow during evaluation (looping recursion?)
```

```
# let rec make_list n list = 
	if n = 0
		then list
	else n :: make_list (n-1) (n::list);;

# let big_list = make_list 10000000 [];;
Stack overflow during evaluation (looping recursion?)
```

```
# let rec make_list n list = 
	if n = 0
		then list
	else make_list (n-1) (n::list);;

# let big_list = make_list 10000000 [];;
```

```
# let rec reverse l = match l with
	| [] -> []
	| h::t -> reverse t @ [h];;
# reverse [1;3;4];;
- : int list = [4; 3; 1]
```

* Function Currying

```
# let add x y = x + y;;

# let add2to_x x = add x 2;;
# let add2to_y y = add 2 y;;
# let add2to_y  = add 2;;
```

* Comments

```
# (* Hello World *)
```

* Trace function call

```
# #trace <function name>;;
```

## Homework

* `subset`
  - a set is a subset of itself
  - the empty set is a subset of any set

* `equal_sets`
  - must use set semantics
  - it is not just "`(=) a b`"
  - `[3;1], [1;3], [1;3;3]` are equal

* fixed point
  - point x such that f x = x
  - computed fixed points:
    `x, f x, f (f x), f (f (f x)), ...`

```
let div2 x = x / 2;;
# div2 8;;
int = 4
# div2 (div2 8);;
int = 2
# div2 (div2 (div2 8));;
int = 1
# div2 (div2 (div2 (div2 8)));;
int = 0
```

* periodic point
  - point `x` such that `f (f ... f(x)) = x` where there are `p` occurrences of `f` in the call

* precision, infinity, and nan
  - `inf * .2` ?
  - `inf / inf` ?
  - `nan = nan` ?
  - `nan * .2 = nan` ?

* grammar
  - symbol -> nonterminal or terminal
  - right hand side -> a list of symbols
  - rule -> pair of (nonterminal, right hand side)
  - grammar -> pair of (start nonterminal syb=mbol, list of rules)

* `filter_blind_alleys`
  - filter out rules that are impossible to derive a terminal string
    + some rules cannot have nonterminals completely substituted out
  
# Sep. 28, 2015

## Administrative

* [Homepage](http://web.cs.ucla.edu/classes/fall15/cs131)

* Syllabus

```
**Theory**            **Practice**
-----------------------------------------
Syntax           <-   OCaml
Semantics        <-   Prolog (most different/weird, stretch understanding of languages)
Functions
Names
Types
Contorl          <-   Scheme (related to Lisp)
Objects          <-   Python
Exceptions
Concurrency      <-   Java
Language Design
               
                  X (last week assignment)
```

* Hours/Week

```
*Actual*    *Reported*
-----------------------------------------
5           6           lectures, discussion
2           2           reading
10          4           homework
     - 3                exams, studying
```

* Grading

40%  Homework
     6 x 5%   homeworks
     1 x 10%  project

20%  Midterm (Wed. 5th week)
40%  Final

- Sample exams
- Open-ended questions (intelligent discussions of the issues)
  - combine topics that seem to be different and discuss

**Learn by debugging (Learning Assistance)**
**Make sure program works (Robust)**
(Non-ASCII input)

## Quiz

Input: a text file ASCII (includes '\n', '\t') plus words

ex. Four score and 7 years ago score and ago and four

Output: 
3 and
2 score
2 ago
1 Four
1 four
1 years

_Shell Script_
```
# Transform all non-ACSII characters into newlines
# Sort the output
tr -cs [A-Za-z] [\n*] | sort | uniq -c | sort -rn
```

Pascal + Literate       vs.     Script
--------------------------------------------------------------------
Better performance              Has false parallelism (not faster)
                                Shorter
                                Easier to maintain
--------------------------------------------------------------------
            Choice of Notation

* Should have a wider choice of programming languages to choose from


## Programming __Notations__ **Languages**

* D.E. Knuth (CalTech -> Stanford)
  - The Art of Computer Programming (TAoCP)
  - Author of TeX (Written in Pascal in the 1970s)
  - The TeXBook

TeX the program    `tex.pas`
TeX the book       `tex.tex`

Changing one leads change to another
Wanted a single notation that could represent both
Created tangled file

--- Tangled file `tex.tang`
    Changes will be localized
    \pi -> 'pi'

--- Literate Programming
    - Express ideas entertainingly for people to read
    - Publicize idea for wider audience
    - CACM --> M.D. Ilroy (Bell Labs)
    - Instead of doing TeX, use a small problem (the quiz above)

      -> machine code
      -> CACM paper

    - Invented new data structure: Hash Trie

### AI software too slow

- in Lisp
- rewrite into C/C++, but C/C++ is a nightmare
  - Create objects temporaily uses (C/C++ requires explicit free/dealloc operations)

Can you suggest some better languages for this problem?

### Why are there so many programming languages?

- Why can't we have just one, one that is flexible?

Metaprogramming: programming environment that you can write about your code in the language that you are using that can be used to generate code.

- Modern: Have many languages in a project & link together
- Not practical to take python program and compile into scheme and expect to work

### Big backend queries in Google's data

- Written a lot of Ad-hoc programs to deal with this problem
- Shell scripts (parallelized), not scalable

- A function model
  - stolen from Lisp/ML
  - called it **MapReduce**
  - _efficient_ & _parallelizable_

### TIOBE Index Sept 2015 (most popular programming languages)

1.  (19.57%) Java
2.  (15.62%) C
3.  (6.78%)  C++
4.  (4.91%)  #C
5.  (3.66%)  Python
6.           PHP
7.           JavaScript
8.           VB.NET
9.           Perl
10. (1.82%)  Objective-C
    ......
33. (0.51%)  Prolog
    ......
47. (0.21%)  ML

Choose a few languages wide apart from goals & principles

### Philosophy of Class

* Principles & Limitations of Programming Models
* Notations for these Models, Designs, Use, Support For
* Methods to Evaluate Strenths + Weaknesses in Various Contexts

--> **CHOICE OF ABSTRACTION**

#### Language Design Issues

* Orthogonality: how independent are they of each other

Language: C
------------
`int f(int g) {}`
`char *f(int g) {}`
`int [100] f(int g) {}` (cannot work, cannot return array)
  - violation of orthogonality (have to worry about return type)
  - return value does not fit in register (efficiency)

Java can return arrays (fixed problem, more modern language)

* Efficiency
  - space, time, power, network access

* Simplicity
  - Thins should be as simple as possible (Albert Einstein)

* Convenience
  - Easy to use (write code, read code)

**Simplicity & Convenience CONFLICT**

Example: Convenient but not Simple
```
i = i + 1;
i += 1;
i++;
++i;
```

* Safety (Security Issues)
  - compile-time (complier warnnings about safety)
  - run-time (run-time good enough to handle problems)
    - C++ (crash if lucky, undefined behavior if unlucky)


























































