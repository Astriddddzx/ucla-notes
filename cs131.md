# CS131: Programming Languages

# Sep. 25, 2015

## CS131 Lab

* Seunghyun Yoo (shyoo1st@cs.ucla.edu)
* Wed 5:30 pm - 6:30 pm, Thu 1:30 pm - 2:30 pm

* Join [Piazza](piazza.com/ucla/fall2015/cs131)

## OCaml

Installation
-------------
* SEASnet: 4.02.3
* Local Machine: ocaml.org

Introduction
-------------
* Functional Programming

```
# let rec fact x = if x <= 1 then 1 else x * fact (x - 1);;
# fact 5;;
-  : int = 120
```

* Using files
  - `# #use 'file-name.ml';;` or `$ ocaml < fact.ml`

* Define Functions

```
# let square x = x * x;;
val square : int -> int = <fun>
# square 3;;
-  : int = 9
```

```
# let add x y = x + y;;
val add : int -> int -> int = <fun>
# add 1 2;;
-  : int = 3
```

```
(cf) # let add (x, y) = x + y;;
val add : int * int -> int = <fun>
```

* If & Match Statement

```
# let max a b = if a > b then a else b;;
val max : 'a -> 'a -> 'a = <fun>
```

```
# let eval_op op v1 v1 =
	match op with
	| "+" -> v1 + v1
	| "-" -> v1 - v2
	| "*" -> v1 * v2
	| _ -> failwith ("undefined");;
```

* List

```
# [ 1; 2; 3 ] ;;
# 1 :: (2 :: (3 :: [])) ;;
# 1 :: 2 :: 3 [] ;;
```

* List Operators

- :: Operator

```
1 :: 2 :: 3 :: []
```

- Appending Lists

```
List.append [1;2;3] [4;5;6];;
[1;2;3] @ [4;5;6];
```

* Extract Data from LIst

```
# let rec sum l = 
	match l with 
	| [] -> 0
	| h :: 5 -> h + sum t;;
# sum [1;2;3];;
# sum [];;
```

* Type

```
type name = typedef;;
type 'a name = typedef;;
```

- Type declarations can be parameterized by type variables

```
# type 'param paired_with_integer = int * 'param;;
# type age type = int;;
# let a: age type = l;;
# type specific_pair = float paired_with_integer;;
# type a' my list = 'a list;;
# type int list = int my list;;
```

* Equal & Identical operator

```
# let a = [ 1; 3 ];;
# let b = [ 1; 3 ];;

# a = b ?
# a == b ?
# a == a ?
```

* Arithmetic Operators

- Must specify type of number explicitly
  * 1 + 0.5;; (not allowed)
  * 1. + 0.5 (not allowed, only for integers)
  * 1. +. 0.5;; (correct)

* Tail Recursion

```
# let rec make_list n = 
	if n = 0
		then []
	else n :: make_list (n-1);;

# let big_list = make_list 10000000;;
Stack overflow during evaluation (looping recursion?)
```

```
# let rec make_list n list = 
	if n = 0
		then list
	else n :: make_list (n-1) (n::list);;

# let big_list = make_list 10000000 [];;
Stack overflow during evaluation (looping recursion?)
```

```
# let rec make_list n list = 
	if n = 0
		then list
	else make_list (n-1) (n::list);;

# let big_list = make_list 10000000 [];;
```

```
# let rec reverse l = match l with
	| [] -> []
	| h::t -> reverse t @ [h];;
# reverse [1;3;4];;
- : int list = [4; 3; 1]
```

* Function Currying

```
# let add x y = x + y;;

# let add2to_x x = add x 2;;
# let add2to_y y = add 2 y;;
# let add2to_y  = add 2;;
```

* Comments

```
# (* Hello World *)
```

* Trace function call

```
# #trace <function name>;;
```

## Homework

* `subset`
  - a set is a subset of itself
  - the empty set is a subset of any set

* `equal_sets`
  - must use set semantics
  - it is not just "`(=) a b`"
  - `[3;1], [1;3], [1;3;3]` are equal

* fixed point
  - point x such that f x = x
  - computed fixed points:
    `x, f x, f (f x), f (f (f x)), ...`

```
let div2 x = x / 2;;
# div2 8;;
int = 4
# div2 (div2 8);;
int = 2
# div2 (div2 (div2 8));;
int = 1
# div2 (div2 (div2 (div2 8)));;
int = 0
```

* periodic point
  - point `x` such that `f (f ... f(x)) = x`
  where there are `p` occurrences of `f` in the call

* precision, infinity, and nan
  - `inf * .2` ?
  - `inf / inf` ?
  - `nan = nan` ?
  - `nan * .2 = nan` ?

* grammar
  - symbol -> nonterminal or terminal
  - right hand side -> a list of symbols
  - rule -> pair of (nonterminal, right hand side)
  - grammar -> pair of (start nonterminal syb=mbol, list of rules)

* `filter_blind_alleys`
  - filter out rules that are impossible to derive a terminal string
    + some rules cannot have nonterminals completely substituted out
  
# Sep. 28, 2015

## Administrative

* [Homepage](http://web.cs.ucla.edu/classes/fall15/cs131)

* Syllabus

```
**Theory**            **Practice**
-----------------------------------------
Syntax           <-   OCaml
Semantics        <-   Prolog (most weird, stretch understanding of languages)
Functions
Names
Types
Contorl          <-   Scheme (related to Lisp)
Objects          <-   Python
Exceptions
Concurrency      <-   Java
Language Design
               
                  X (last week assignment)
```

* Hours/Week

```
*Actual*    *Reported*
-----------------------------------------
5           6           lectures, discussion
2           2           reading
10          4           homework
     - 3                exams, studying
```

* Grading

```
40%  Homework
     6 x 5%   homeworks
     1 x 10%  project

20%  Midterm (Wed. 5th week)
40%  Final
```

- Sample exams
- Open-ended questions (intelligent discussions of the issues)
  - combine topics that seem to be different and discuss

**Learn by debugging (Learning Assistance)**
**Make sure program works (Robust)**
(Non-ASCII input)

## Quiz

Input: a text file ASCII (includes '\n', '\t') plus words

ex. Four score and 7 years ago score and ago and four

Output: 
3 and
2 score
2 ago
1 Four
1 four
1 years

_Shell Script_
```
# Transform all non-ACSII characters into newlines
# Sort the output
tr -cs [A-Za-z] [\n*] | sort | uniq -c | sort -rn
```

```
Pascal + Literate       vs.     Script
--------------------------------------------------------------------
Better performance              Has false parallelism (not faster)
                                Shorter
                                Easier to maintain
--------------------------------------------------------------------
            Choice of Notation
```

* Should have a wider choice of programming languages to choose from


## Programming **Notations Languages**

* D.E. Knuth (CalTech -> Stanford)
  - The Art of Computer Programming (TAoCP)
  - Author of TeX (Written in Pascal in the 1970s)
  - The TeXBook

TeX the program    `tex.pas`
TeX the book       `tex.tex`

Changing one leads change to another
Wanted a single notation that could represent both
Created tangled file

* Tangled file `tex.tang`
  - Changes will be localized
  - \pi -> 'pi'

* Literate Programming
  - Express ideas entertainingly for people to read
  - Publicize idea for wider audience
  - CACM --> M.D. Ilroy (Bell Labs)
  - Instead of doing TeX, use a small problem (the quiz above)

      -> machine code
      -> CACM paper

    - Invented new data structure: Hash Trie

### AI software too slow

- in Lisp
- rewrite into C/C++, but C/C++ is a nightmare
  - Create objects temporaily uses (C/C++ requires explicit free operations)

Can you suggest some better languages for this problem?

### Why are there so many programming languages?

- Why can't we have just one, one that is flexible?

Metaprogramming: programming environment that you can write about your code in the language that you are using that can be used to generate code.

- Modern: Have many languages in a project & link together
- Not practical to take python program and compile into scheme and expect to work

### Big backend queries in Google's data

- Written a lot of Ad-hoc programs to deal with this problem
- Shell scripts (parallelized), not scalable

- A function model
  - stolen from Lisp/ML
  - called it **MapReduce**
  - _efficient_ & _parallelizable_

### TIOBE Index Sept 2015 (most popular programming languages)

1.  (19.57%) Java
2.  (15.62%) C
3.  (6.78%)  C++
4.  (4.91%)  #C
5.  (3.66%)  Python
6.           PHP
7.           JavaScript
8.           VB.NET
9.           Perl
10. (1.82%)  Objective-C
    ......
33. (0.51%)  Prolog
    ......
47. (0.21%)  ML

Choose a few languages wide apart from goals & principles

### Philosophy of Class

* Principles & Limitations of Programming Models
* Notations for these Models, Designs, Use, Support For
* Methods to Evaluate Strenths + Weaknesses in Various Contexts

--> **CHOICE OF ABSTRACTION**

#### Language Design Issues

* Orthogonality: how independent are they of each other

Language: C
------------
`int f(int g) {}`
`char *f(int g) {}`
`int [100] f(int g) {}` (cannot work, cannot return array)
  - violation of orthogonality (have to worry about return type)
  - return value does not fit in register (efficiency)

Java can return arrays (fixed problem, more modern language)

* Efficiency
  - space, time, power, network access

* Simplicity
  - Thins should be as simple as possible (Albert Einstein)

* Convenience
  - Easy to use (write code, read code)

**Simplicity & Convenience CONFLICT**

Example: Convenient but not Simple
```
i = i + 1;
i += 1;
i++;
++i;
```

* Safety (Security Issues)
  - compile-time (complier warnnings about safety)
  - run-time (run-time good enough to handle problems)
    - C++ (crash if lucky, undefined behavior if unlucky)

# Sep. 30, 2015

## Programming Language Catetories

Imperative vs. Functional vs. Logic
Objective Oriented vs. Non Objective Oriented
Compiled vs. Scripting

### Imperative/Procesural Languages (most common & popular)

**COMMANDS**

* In sequence

### Functional Languages

**FUNCTIONS**

* NO commands
* Evaluate expression
* Calling functions
* `F1(F2(x))` (Can also use C this way)

### Logic Languages

**PREDICATES**

* `P1(x) & P2(x)`
* Don't evaluate
* Don't execute
* Theorem proving program (?)
* Highest level


## John Backus

* Developed Fortran
* Discovered that imperative code had problems, buggy code
* Hard to understand
* Sequencing is crutial
* Adopting the imperative style sets programmers off from the mathematics world
* Breaking the rules of the mathematical world

```
y = a[i];
i++;
x = a[i];
```

**a[i] CHANGES!!!**

## New Habit **(!)**

* No assigning variables
  - OCaml: variables in functions cannot change
  - Referential transparency

## Functional Language Motivation

Clarity
--------
* Build on hundreds of years of experience with **mathematical notation**

Notation
---------
* To compute with functions rather than recipes (sequential steps)
* **Function Definition**: mapping from a **domain** to a **range**
  - Figure out what domains & ranges are
  - Domains & ranges may include functions themselves
  - Functional form: domain or range are functions
    + `F [o](compose) G (x) = F(G(x))`
      - `[o](compose)` is a function that takes functions as inputs

Performance
------------
* von Neumann bottleneck

```
  +-----+  --->  +-----+
  | CPU |        | RAM |  (not parallel)
  +-----+  <---  +-----+
```

* Get better clarity and performance with functional style

```
(1) a = f(b,c);
i++;
(2) x = g(y,z);
```
Can execute `(1)` & `(2)` in parallel only if `f()` & `g()` don't look at i

* Try to figure out methods to write code without assignments
* Assignment statments lead to undefined behavior

## OCaml

* General-purpose
* Object-oriented
* Has assignment statements (but don't use)
* OCaml (SoCal) != ML (East-coast)

* Has both compiler & interpreter

```
    OCaml                                ML
-----------------------------------------------------------------
x < y && y < z                 x < y and also y < z
  3. +. 1.5                         3. + 1.5
   [1;2;3]            [1,2,3]  can also use for tuples (1,"abc")
-----------------------------------------------------------------
```

Basic Properites
-----------------
* Good support for **functions** + **functional forms** (much better than in Java or C)
* **Compile-time type checking** (like C++, Java) (unlike Python, Scheme)
* Heavy-duty **type inference**
* No need to worry about storage management, has **garbage collection** (unlike C/C++) (like Java, Python)

### Startup

Start by using `$ ocaml`

```
# 3 + 4 * 5;;
-: int = 23
# let x = 37 * 37;;
x: int = 1369
# if 3 < 5 then "a" else "b";; (* 3<5?"a":"b" in C *)
-: string = "a"

# if 3 < 5 then "a" else 0;;
[error, wrong type]

# (1,2, "a");; (* tuple *)
-: int * int * string = (1, 2, "a") (* cross product for '*' *)
# [1; 2];;
-: int list = [1, 2]

# ();;
-: unit = ()
# [];;
-: 'a list = []

# [1; 3] @ [5];;
-: int list = [1; 3; 5]
# [1; 3] @ [];;
-: int list = [1; 3]

(* functions *)
# let f x = x + 1
# let f = fun x -> x + 1;;
val f: int -> int = <fun>

# let cons (a,b) = a::b;;
val cons: 'a * 'a list -> 'a list = <fun>
# let cons x = match x with | (a,b) -> a::b;;
```

### Paterns in OCaml

```
patterns        what they match
--------------------------------------------------
0               0
--------------------------------------------------
[]              []
--------------------------------------------------
a,b             any tuple of 2 elements
                (binds 1st to a, 2nd to b)
--------------------------------------------------
h::t            binds h to 1 element, t to
                remaining list (can be empty)
--------------------------------------------------
(a,b)::t        (group patterns)
--------------------------------------------------
a               matches anything, binds to a
--------------------------------------------------
_               matches anything & discards
--------------------------------------------------
_,b             discards first, binds second to b
--------------------------------------------------
```

* match expressions

```
match x with
  | P1 -> E1
  | P2 -> E2
  | Pn -> En
```

```
match l with
  | _::_::x::_ -> x
  | _::x::_ -> x
  | x::_ -> x
  | _ -> 0
```

```
# let ccons a b = a::b;;
val ccons: 'a -> 'a list -> 'a list = <fun> (* functional form *)

(* lambda expression, don't need name *)
# let ccons a = fun b -> a::b;;
# let ccons = fun a -> fun b -> a::b;;
val ccons: 'a -> 'a list -> 'a list = <fun>

(* function call is left-associative *)
# ccons "abc" ["def"; "ghi"];;
# (ccons "abc") ["def"; "ghi"];; (* equivalent *)

# let ccons0 = ccons 0
val ccons0: int list -> int list = <fun>
# ccons0 [1; 2];;
-: int list = [0; 1; 2]
```

```
# let hd h::_ = h;;
Warning: hd is a partial function, some patterns won't match
val hd: 'a list -> 'a <fun>
# let hd = fun x ->
  match x with
  | h::_ -> h;; (* Doesn't work on empty lists *)
```

* Always match all patters
* Don't use head and tail functions

Safe head function
```
# let sfhd = function
  | h::_ -> h
  | _ -> 0;;
val sfhd: int list -> int = <fun>

# let safehd d = function
  | h::_ -> h
  | _ -> d;;
val safehd: 'a -> 'a list -> 'a = <fun>
```

### Recursion

* Always write the `rec` keyword

```
(* buggy code *)
# let rec reverse = function
  | [] -> []
  | h::t -> (reverse t) @ h
val reverse: 'a list list -> 'a list = <fun>
# reverse [ [1; 2]; [2; 3] ];;
-: int list = [2; 3; 1; 2]
# reverse [1;2;3];;
Error: This expression has type int but an expression was expected of type 'a list
```

**SLOW CODE**
```
# let rec reverse = function
  | [] -> []
  | h::t -> (reverse t) @ [h]
val reverse: 'a list -> 'a list = <fun>
```

# Oct. 5, 2015

## Why is this slow?

* Computes reverse recursively of each tail
* Cost of O(A@B) = |A|
* This cost is calculated at every level of recursion

* O(N^2) 

### Idea

* Add an **accumulator** by adding an argument to our function

```
# let rec rev l [work to be done] a [work already done] =
  match l with
  | [] -> a
  | h::t -> rev t (h::a);;
val rev: a' list -> 'a list -> 'a list

# let reverse l = rev l [];;
```

## Currying

* Representing multiple functions by making a function that returns a function
* **higher-level-functions**

```
# let rec rev1 a l =
  match l with
  | [] -> a
  | h::t -> rev1 (h::a) t
```

can be changed into

```
# let rec rev1 a = function
  | [] -> a
  | h::t -> rev1 (h::a) t
```

Then we can have

```
# let reverse = rev1 [];;
```

### Find minimum value in list

```
# let rec minval = function
  | h::t -> let m = minval t in 
                      if h < m
                      then h
                      else m
  | [] -> ? (2^63-1);;
```

pass in a less than function

```
# let rec minval lt inf = function
  | h::t -> let m = minval lt inf t in
                      if lt h m
                      then h
                      else m
  | [] -> inf;;
```

Then our minval function is

```
# let minvalint = minval (<) 2^63-1;;
# let maxvalint = minval (>) -2^63-1;;
```

## Types

* Self-defined types
  - `# let color = R|G|B;;`
  
```
  +---+ +---+ +---+
  | R | | G | | B |
  +---+ +---+ +---+
```
```
# let colorval = function
  | R -> 0
  | G -> 1
  | B -> 2;;
# colorval B
-: int 2
```

```
# type 'a option =
  | Some of a
  | None
```

```
option
+------+----+
| Some | `a |
+------+----+
| None |
+------+
```

```
# let rec crazyminval lto inf = function
  | [] -> inf
  | h::t -> let m = crazyminval lto inf t in
              match lto with
              | None -> inf
              | Some lt -> if lt h m
                            then h
                            else m;;
```

```
crazyminval (Some (<)) 2^63-1 [3; -2; 19]
```

* `in` keyword

```
# let x = 37 * 37 in x - 3
-: 1366;;
```

```
# type 'a mylist =
  | Empty
  | Cons of 'a * 'a mylist;;
```

```
# let rec myconcat l m = 
  match l with
  | Empty -> m
  | Cons (h,t) -> Cons (h, myconcat, t m);;

# let rec myreverse = function
  | Empty -> Empty
  | Cons (h,t) -> myconcat (myreverse t) Cons (h, Empty);;
```

## Mutability of Languages

* Successful programming languages evolve, even Fortran, C++

* BASIC on the GE225 (16m^3)
  - 40 micro-seconds to add
  - 500 micro-seconds to divide
  - 40 KiB RAM
  - 20 users
  - Rules on this machine
    + Identifiers have 1-2 chars
    + Strings have $[a-z]

* C
  - was developed for a 16-bit minicomputer (1974)
  - 4 micro-seconds to add
  - 16 KiB RAM
  - 1.2 micro-seconds memory cycle time
  - Rules
    + define-before-use identifiers (small memory)
    + *operator *p (fast) p[0] faster than p[5]
      - add = 3x load
      - load = 100x add (try avoiding talking to RAM)

## Evolving (Changing) C

```
Obj args[7];
args[0] = f(x);
args[1] = g+3;
   ...
args[6] = malloc(19);
Foo (7, args);

// wanted to write
Foo (f(x), g+3, ..., malloc(19));
```

Define macros

```
#define ELTS (a) (sizeof (a) / sizeof (a[0]))
#define CALLMANY (f, args) \
  (f) (ELTS (args), args)
#define CALLN (f, ...) \
  CALLMANY (f, ((Obj[]) {__VA_ARGS__} ))
```

And get better syntax

```
CALLMANY ((Foo, f(x), g+3, ..., malloc(19)));
```

### sh (Bourne shell)

```
if (x < y) {
  x += y;
} else {
  x -= y;
}

// wanted

if x < y then
  x += y
else
  x -= y
fi
```

Defined macros

```
#define IF if (
#define THEN ) {
#define ELSE ;} else {
#define FI ;}
```

Then we could write

```
IF x < y THEN
  x += y
ELSE
  x -= y
FI
```

### Sapir-Wharf Hypothesis

* the language we use determines how to view the world & how we think

## Syntax

* Part of the language where we talk about formalism
* Form independent of meaning
* "Colorless green ideas sleep furiously" (N. Chomsky)
  - nice syntax but bogus meaning
* "Ireland has leprechauns galore (adj. modifies leprechauns)." (P. Eggert)
  - "galore" comes from Irish
  - adjectives come after nouns in Irish

`int main (int argc, char **argv) { return argc+++argv[0][0]; }`


### Ambiguity

``` 
"Time flies."
  N     V    (time has gone really fast)
  V     N    (measure how fast flies fly)
``` 

* syntactic & semantic

```
{
  int a = 10, b = 20;
  return a++++b;
  // can be (a++)+(+b);
  // can be a+(+(++b));
}
```

# Oct. 7, 2015

## How to choose a syntax

### Reasons to prefer one syntax to another

1. It's what people are used to

  - `a < b`, `a-b`
  - `-a-b`, `a--b`, `a- -b`
  - `a*b-c`, `a-b*c`

2. It's simple & regular (smallest grammar)

  - `(< a b)`, `(- a b)`, `(- (- a) b)`

3. It's _"readable"_

**Leibniz's Criterion** - a proposition's form should mirror reality

  - `let x = 37 * 3 in x * x`
  - `(fun x -> x * x) 37 * 3` (out-of-order, right to left)

  - `if (x >= 0 && x < n) print ("OK");`
  - `if (0 <= x < n) print ("OK");` (always use less than, not greater than)

4. It's _"writable"_

**Concise**

  - Too prolix: Java: `Thread x = new Thread(s);`
  - Too concise: APL (write-only code): `z N // numbers 1 - 10`, `*/ z N // multiply`

5. It's redundant

**Catch Stupid Mistakes**

  - `n = (3+4)*i*(j+2); // parentheses matching`
  
  - Violation example

```
DO 10 I = 1,100
// Typo: DO 10 I = 1.100
// which becomes: DO10I = 1.1
  code goes here, involving I
  10 CONTINUE
```

  - C: `if (i == 0)` vs. `if (i = 0)`

```
# if INT_MIN < SHRT_MIN (typo: SHORT_MIN -> evaluate to 0 (not defined))
  ... cde ...
# endif
```

6. It's ambiguous

* C

```
int sum3 (int a, int b, int c) {
  return a + b + c; 
  // implied parentheses -> integer overflow, rounding errors
  // standard: (a + b) + c
}
```

* Fortran

Not defined, allows compiler to choose order (performance)

### At low level

```
                                                          program = byte string
+-------+----+--------+------------+------------------------------------------+
|       | 93 |        | multi-byte |                                          |
+-------+-|--+--------+------|-----+------------------------------------------+
Phase 0   |                  |
          |                  |
          |                  |                       program = character string
+-------+-|-+-------------+--|--+---------------------------------------------+
|       | a |             | 'c' |                                             |
+-------+---+-------------+-----+---------------------------------------------+
Phase 1
```

Unicode
--------
`printf("Invalid word '%s'\n", foo);`

* ASCII is represented as the same in Unicode

```
4 bytes/char       UTF-32
---------------------------
                   UTF-8

+---+-------------+
| 0 | <--- 7 ---> | payload
+---+-------------+

+---+---------------++----+-----+---------++----+-----+---------+
| 1 | 110 | payload || 10 | 110 | payload || 10 | 110 | payload |
+---+---------------++----+-----+---------++----+-----+---------+
```

* 2 different byte representations for same character!

`strcmp (a,b)` -> different

```
encoding error

+----------+----------+--------+
| 11100011 | 01011010 | ...... |
+----------+----------+--------+
   UTF-8      ASCII

UTF-8 & ASCII don't match -> encoding error
```

* example C program

`int main (void) { return 42 /* the answer */; }`

* Phase 0: interpret

* Phase 1: throw away spaces, newlines, comments

* Phase 2: Tokenization or Lexical Analysis (lexing)

`INT(12) ID(1) ((13) VOID(19) )(16) {(26) RETURN(31) NUM(3) ;(14) }(27)`

  - Tokens
    * comments
    * white space
    * identifiers
      + `int x;`
      + `int int` (?)
        - reserved words
        - adding reserved words will invalidate old programs
        - `noreturn` - 
          + `noreturn void error (void) { printf("Error!"); exit; }`
          + C99: `int noreturn = 19; // would not work in C11`
          + Added keyword `_Noreturn` instead
      + `int class = 12; // works in C`
      + A language with keywords but no reserved words (**PL/I**)
        - `if (if = if) THEN if(else) = if; else if(else) = else;`
        - complicates grammar & lexing


### Parse Tree

```

                    program
                       |
                    fn decls
                       |
                     fn decl
       +-----+--------+---------------------+
       |     |        |                     |
     type    ID      args                  body
       |         +----+------+    +---------+----------+
       |         |    |      |    |         |          |
      INT        (  arglist  )    {      stmt list     }
                      |                     |
                     VOID               return stmt
                                      +---------+--------+
                                      |         |        |
                                    RETURN     expr      ;
                                                |
                                               NUM
```

## Definitions

* Grammar

formal description of a language

* Language

(infinite) set of strings
Language for English is recursive

* String

finite sequence of tokens

* Token

member of a known fixed finite set

# Oct. 14, 2015

* By next time, read Webber Chapters 1-9, 11

## Disambiguation of Grammar

* Makes grammar more complicated
* Which generates more complicated parse trees & derivations

**Simple Grammar**
```
  E -> E + E
  E -> E * E
  E -> ID

  a + b * c

      E
  +---+---+
  |   |   |
  a   +   E
        +-+-+
        b * C

```

**Unambiguous Grammar**
```
  E -> E + T
  E -> T
  T -> T * F
  T -> F
  F -> ID

  a + b * c

      E
  +---+---+
  |   |   |
  E   +   T
  |     +-+-+
  a     T * F
        |   |
        b   c
```

* Abstract systax parse tree
* Settle precedence
* Write simple grammar, let compiler settle unambiguity

### Really complicated syntax

* With long grammar
* e.g. SQL variations
* even EBNF is too prolix

* Use syntax diagrams/graphs/charts/racetrack diagrams

**Example: Scheme _cond_**

```
<cond> -> (cond <cond claus>+ 
        | (cond <cond clause>* 
                (else <sequence>))
```

**_Diagram_**

```
cond
                     +--->---->---->--+
                     |                | 3
  ---> ( ---> cond --+-> cond clause -+--> ( ---> else ---> sequence ---> ) -+-> )
          1        2 | 4              |                                      |
                     +---<----<----<--+                                      |
                                      |                                      |
                                      +--------->--------->---------->-------+
```

1) for clarity
2) for advice about parsing

```
parse_cond () 
{
  parse_token ("(") &&
  parse_token ("cond") &&
  if (parse_cond_clause ())
    parse_cond_clause_sequence ();
  else
    parse_token ("(") &&
    parse_token ("else") &&
    ......
}
```

**Easy Case:**

* diagrams contain only tokens
* finite state automaton (**can only parse simple languages**)
* DFA (deterministic FA) (implemented via lookup table)
* NFA (nondeterministic FA)

```
          input token #s
         +----------------+
         |                |
         |                |
         |                |
state #s |         * --------> next state (FA)
         |         |      |
         |         +-------------> set of next states (NFA)
         |                |
         +----------------+
```

```
   b
0 -+--> 2
   |    ^
   |    | b
   |    +
 a +--> 1 -+
    ^      | a
    +------+ 
```

*they can't do arbitrary recursion*
```
  S -> b
  S -> a S  <--- if grammar is tail recursive, you're ok
```

arbitrary recursion: combine a  FA  +  stack (extra memory)
                      **HW2:  match    recursive function**  
(can do any context free grammar)

# HW2

* Recursive Grammar

`S -> a b  S  c`

* Concatenation

`S -> T U`

* Disjunction (OR)

```
S -> T
S -> U
(S -> T|U) 
```
**HARD PART**


**Acceptor**
Implements OR atop concatenation

I'll parse T, give the T-parse an acceptor that allows only U
This gives the T-parser a way to do disjunction inside itself

```
S -> T U
T -> T1
T -> T2
```

```
S -> b
S -> a S
```

`Worst case: 'N' tokens  ->  O(2^N)`

### Prolog

* Lets you define operators

```
:-op (500,     yfx, [+,-]);
(precedence)  (infix) (left associative)

:-op (400, yfx, [*,/]);
:-op (200, xfy, [**]);
:-op (700, xfx, [=,\=,==, =<...]) (cannot do a = b = c)
                                 valid in C: a == b == c
                                             (a < b) < c
:-op (200, fy, [+,-]);
```

### Bug with stack

```
double stack[100000];
double *sp = &stack[100000];
#define PUSH(x) (*--sp = (x))
#define POP() (*sp++)

switch (op) {
  case '+': PUSH(POP() + POP()); break;
  case '-': PUSH(-POP() + POP()); break;
  case '*': PUSH(POP() * POP()); break;
  case '/': PUSH(1/POP() * POP()); break;
}
```

Expand to: `*--sp = *sp++ + *sp++;`

Java: L to R
C: doesn't enforce, L to R  ||  R to L  ||  mixed order (parallel)
   undefined behavior if competing side effects, compiler can do anything

Problem: Core Dump
`*sp++ + *sp++` **may evaluate in parallel (increment sp twice)**

Try fixing it with functions

```
void PUSH (double d) { *--sp = d; }
double POP (void) { return *sp++; }
```

## Semantics

Translation Steps

```
byte strings --> char strings --> token strings --> parse tree (derivation)
|                                             |     |                     |
+----------------------+----------------------+     +-----------+---------+
                     lexing                                  parsing

-----------------> attributed tree ---------------> simple abstract machine
name resolution                     intermediate    +---------------------+
type checking                        code gen       | main:               |
                                                    |---------------------|
                                                    |   push    getchar   |
                                                    |   call    0         |
                                                    |   logng             |
                                                    |   ret               |
                                                    +---------------------+

|                                                                         |
+-------------------------------------+-----------------------------------+
                          machine independent code

                           machine dependent code
+-------------------------------------+-----------------------------------+
|                                                                         |

--> machine dependent code -----> optimization ------> asm --> ld --> load
   +---------------------+     +-----------------+      |       |      |
   | leal  getchar, %eax |     | call getchar    |      *       |      *
   | pushl %eax          |     | tstl %eax, %eax |   .o file    |     RAM
   | popl  %eax          |     | sete %el        |              *
   | call  *%eax         |     | ret             |          executable
   | tstl  %eax, %eax    |     +-----------------+
   | sete  %el           |
   | ret                 |
   +---------------------+
```

Software tools approach (Unix, Linux)
--------------------------------------
- Easy to replace components

Integrated Development Environment (IDE)
-----------------------------------------
* Small talk

Traditionally:
  compilers: translate Fortran to x86-64 efficient execution
  interpreters: execute BASIC programs directly via a machine language interpreter

Traditional Java
  javac (compiler)
  can be done on separate machines

```
                           +------------------+
Foo.java --> Foo.class --> | Java Interpreter |
                           +------------------+
+--- databases server ---+ +----- client -----+
```

**JIT (Just In Time) Compiling**

```
Java Interpreter + bytecode -> machine code -> compiler
(counts #times 
code gets executed) --> machine code
```

### Dynamic Linking

A program can call the linker
  ("Please link in a JPEG decompression library")
 
`f = ... (return a pointer to function)`
`f (...)`

  Problems:
    type checking? (How to do at run-time instead of static compile-time)
    run-time checking?

Check linking: `$ ldd a.out`

# Oct. 19, 2015

## What is a type?

**`Definition A`**
**A set of values** for variables
**A set of operations** on those variables

_Language SETL: types are sets_

```
double + int -> double // double dominates
int + double -> double // double dominates
```

```
double + int64_t -> double
int64_t + double -> double
```

**`Definition B`**
A type is a set of information known about a value at compile time
This assumes static type checking at compile checking

The following do not fall into `Definition A`
`int const a = 27;`
`int volatile v = 27;`

**However this definition does not work for types with dynamic type checking**

## Primitive vs. Constructed Types

**Primitive**: Built-in yypes

**Constructed**: Built by programmer using type constructors

_C Language Primitive Types:_

```
long
unsigned long
int
double
char
bool
signed char
unsigned char
float
long double
```

_C Language Constructed Types:_

```
T *
T const
T volatile
T []
T (*)(T1, T2, ..., Tn)
// (they nest!)
struct ...
union ...
```

_C++:_ `class T { ... }`

## Example: `float`

```
+---+---+----------------+
| 1 | 8 |       23       |
+---+---+----------------+
  s   e         f
   
Normalized:
(+-) 2^(e-127) * 1.f // (0 < e < 255)

Denormalized and (+-0):
(+-) 2^(-126) * 0.f // (e = 0)

(+-) 0 for reminding from which side underflow came from

Infinity:
(+-) inf // (f = 0, e = 255)
1.0/0.0 = inf
1.0/-0.0 = -inf

NAN (Not A Number):
(+-) NAN(f) // (f != 0, e = 255) (f gives information on nan)
inf + inf = inf
inf - inf = nan
0.0/0.0 = nan(0)
nan + 1 = nan
nan / nan = nan

if (nan == nan) ---> evaluates to false even if both nans have same value
```

```
float a = ...;
float b = ...;

a != b && a - b == 0 // can't happen in real, but can happen in C
```

Instead of using inf, nan
Let's trap / signal an error / throw an exception

## Terminology

**abstract vs. exposed types**

```
abstract          vs     exposed types
----------------------------------------------
ops only                 ops + details
way to make progress     about representation
```

```
struct complex {      +------+------+
  double re;          |  re  |  im  |
  double im;          +------+------+
}
```

**strongly typed**
all operations are type checked (compile or run-time)

Java & OCaml are stronly typed
C/C++ are not

```
double d;
int i;
i = d;
```

```
char c = 'a';
char d = c (char) + 1 (int); // still strongly typed
```

```
int a = 29;
void *p = &a;
long *q = p;
return *q; 
// works find on x86 (int and long are the same length)
// undefined on x86-64, may dump core
```

**equivalent types**

_structural equivalence_
`T1 = T2` if they have same layout in memory

```
typedef char * t1;
typedef char * t2;
t1 a; t2 b;
a = b;
b = a; 
// this works
// for typedef's, C uses structural equivalence
```

*Structural equivalence is important in C because*

```
typedef unsigned long size_t
size_t n; n = n + 1; // has to be able to work
```

```
struct s { double re, im; struct t * next };
struct t { double re, im; struct s * next };
```

_name equivalence_
`T1 = T2` if they have the same name

```
struct s { double re, im; };
struct t { double re, im; };

struct s = a;
struct t = b;

a = b;
b = a; // compiler error, incompatible types, different names
```

**subtypes**

*Pascal:* `type lower = 'a' .. 'z';`
`lower` is **subtype** of `char`

*CommonList:* (declare (type (and integer (satisfies evenp)) x))

_*subtypes inherit operations of supertypes*_
_*subtypes have more operatison than supertypes*_

```
s = char *
t = char const *

Is 's' a subtype of 't' or is 't' a subtype of 's'?
---> 's' is a subtype of 't'
```

```
char *p = ...;
char const *q = ...;

p = q; // not allowed because 'q' is a subtype of 'p'
q = p; // this works

'volatile' works the same as 'const'
```

**polymorphism**

function that accepts many types is called "polymorphic"
relevant mostly for compile-time checking

_*overloading*_

identify function from its operands' types

C++:
`complex operator + (complex, complex);`
`A + B` if `A` and `B` are both complex then use the above

Ada:
also looks at the context (result type)
```
int a = ...;
int b = ...;
double d =  a  +  b;
          (int) (int)
```

```
                             name mangling
foo  int double             foo  $int $double
foo  double int             foo  $double $int
foo  int int                foo  $int $int
foo  int short              foo  $int $short
foo  float double           foo  $float $double
```

**coercion**

system converts types as need to make things work

`a (float) + b (int) // coerce 'b' to type float`

_Problems:_
Coercion can lose information
Complicates language

`foo (a (float), b (int)) // can have many matches`


















