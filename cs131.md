# CS131: Programming Languages

# Sep. 25, 2015

## CS131 Lab

* Seunghyun Yoo (shyoo1st@cs.ucla.edu)
* Wed 5:30 pm - 6:30 pm, Thu 1:30 pm - 2:30 pm

* Join [Piazza](piazza.com/ucla/fall2015/cs131)

## OCaml

Installation
-------------
* SEASnet: 4.02.3
* Local Machine: ocaml.org

Introduction
-------------
* Functional Programming

```
# let rec fact x = if x <= 1 then 1 else x * fact (x - 1);;
# fact 5;;
-  : int = 120
```

* Using files
  - `# #use 'file-name.ml';;` or `$ ocaml < fact.ml`

* Define Functions

```
# let square x = x * x;;
val square : int -> int = <fun>
# square 3;;
-  : int = 9
```

```
# let add x y = x + y;;
val add : int -> int -> int = <fun>
# add 1 2;;
-  : int = 3
```

```
(cf) # let add (x, y) = x + y;;
val add : int * int -> int = <fun>
```

* If & Match Statement

```
# let max a b = if a > b then a else b;;
val max : 'a -> 'a -> 'a = <fun>
```

```
# let eval_op op v1 v1 =
	match op with
	| "+" -> v1 + v1
	| "-" -> v1 - v2
	| "*" -> v1 * v2
	| _ -> failwith ("undefined");;
```

* List

```
# [ 1; 2; 3 ] ;;
# 1 :: (2 :: (3 :: [])) ;;
# 1 :: 2 :: 3 [] ;;
```

* List Operators

- :: Operator

```
1 :: 2 :: 3 :: []
```

- Appending Lists

```
List.append [1;2;3] [4;5;6];;
[1;2;3] @ [4;5;6];
```

* Extract Data from LIst

```
# let rec sum l = 
	match l with 
	| [] -> 0
	| h :: 5 -> h + sum t;;
# sum [1;2;3];;
# sum [];;
```

* Type

```
type name = typedef;;
type 'a name = typedef;;
```

- Type declarations can be parameterized by type variables

```
# type 'param paired_with_integer = int * 'param;;
# type age type = int;;
# let a: age type = l;;
# type specific_pair = float paired_with_integer;;
# type a' my list = 'a list;;
# type int list = int my list;;
```

* Equal & Identical operator

```
# let a = [ 1; 3 ];;
# let b = [ 1; 3 ];;

# a = b ?
# a == b ?
# a == a ?
```

* Arithmetic Operators

- Must specify type of number explicitly
  * 1 + 0.5;; (not allowed)
  * 1. + 0.5 (not allowed, only for integers)
  * 1. +. 0.5;; (correct)

* Tail Recursion

```
# let rec make_list n = 
	if n = 0
		then []
	else n :: make_list (n-1);;

# let big_list = make_list 10000000;;
Stack overflow during evaluation (looping recursion?)
```

```
# let rec make_list n list = 
	if n = 0
		then list
	else n :: make_list (n-1) (n::list);;

# let big_list = make_list 10000000 [];;
Stack overflow during evaluation (looping recursion?)
```

```
# let rec make_list n list = 
	if n = 0
		then list
	else make_list (n-1) (n::list);;

# let big_list = make_list 10000000 [];;
```

```
# let rec reverse l = match l with
	| [] -> []
	| h::t -> reverse t @ [h];;
# reverse [1;3;4];;
- : int list = [4; 3; 1]
```

* Function Currying

```
# let add x y = x + y;;

# let add2to_x x = add x 2;;
# let add2to_y y = add 2 y;;
# let add2to_y  = add 2;;
```

* Comments

```
# (* Hello World *)
```

* Trace function call

```
# #trace <function name>;;
```

## Homework

* `subset`
  - a set is a subset of itself
  - the empty set is a subset of any set

* `equal_sets`
  - must use set semantics
  - it is not just "`(=) a b`"
  - `[3;1], [1;3], [1;3;3]` are equal

* fixed point
  - point x such that f x = x
  - computed fixed points:
    `x, f x, f (f x), f (f (f x)), ...`

```
let div2 x = x / 2;;
# div2 8;;
int = 4
# div2 (div2 8);;
int = 2
# div2 (div2 (div2 8));;
int = 1
# div2 (div2 (div2 (div2 8)));;
int = 0
```

* periodic point
  - point `x` such that `f (f ... f(x)) = x` where there are `p` occurrences of `f` in the call

* precision, infinity, and nan
  - `inf * .2` ?
  - `inf / inf` ?
  - `nan = nan` ?
  - `nan * .2 = nan` ?

* grammar
  - symbol -> nonterminal or terminal
  - right hand side -> a list of symbols
  - rule -> pair of (nonterminal, right hand side)
  - grammar -> pair of (start nonterminal syb=mbol, list of rules)

* `filter_blind_alleys`
  - filter out rules that are impossible to derive a terminal string
    + some rules cannot have nonterminals completely substituted out
  
# Sep. 28, 2015

## Administrative

* [Homepage](http://web.cs.ucla.edu/classes/fall15/cs131)

* Syllabus

```
**Theory**            **Practice**
-----------------------------------------
Syntax           <-   OCaml
Semantics        <-   Prolog (most different/weird, stretch understanding of languages)
Functions
Names
Types
Contorl          <-   Scheme (related to Lisp)
Objects          <-   Python
Exceptions
Concurrency      <-   Java
Language Design
               
                  X (last week assignment)
```

* Hours/Week

```
*Actual*    *Reported*
-----------------------------------------
5           6           lectures, discussion
2           2           reading
10          4           homework
     - 3                exams, studying
```

* Grading

```
40%  Homework
     6 x 5%   homeworks
     1 x 10%  project

20%  Midterm (Wed. 5th week)
40%  Final
```

- Sample exams
- Open-ended questions (intelligent discussions of the issues)
  - combine topics that seem to be different and discuss

**Learn by debugging (Learning Assistance)**
**Make sure program works (Robust)**
(Non-ASCII input)

## Quiz

Input: a text file ASCII (includes '\n', '\t') plus words

ex. Four score and 7 years ago score and ago and four

Output: 
3 and
2 score
2 ago
1 Four
1 four
1 years

_Shell Script_
```
# Transform all non-ACSII characters into newlines
# Sort the output
tr -cs [A-Za-z] [\n*] | sort | uniq -c | sort -rn
```

```
Pascal + Literate       vs.     Script
--------------------------------------------------------------------
Better performance              Has false parallelism (not faster)
                                Shorter
                                Easier to maintain
--------------------------------------------------------------------
            Choice of Notation
```

* Should have a wider choice of programming languages to choose from


## Programming **Notations Languages**

* D.E. Knuth (CalTech -> Stanford)
  - The Art of Computer Programming (TAoCP)
  - Author of TeX (Written in Pascal in the 1970s)
  - The TeXBook

TeX the program    `tex.pas`
TeX the book       `tex.tex`

Changing one leads change to another
Wanted a single notation that could represent both
Created tangled file

* Tangled file `tex.tang`
  - Changes will be localized
  - \pi -> 'pi'

* Literate Programming
  - Express ideas entertainingly for people to read
  - Publicize idea for wider audience
  - CACM --> M.D. Ilroy (Bell Labs)
  - Instead of doing TeX, use a small problem (the quiz above)

      -> machine code
      -> CACM paper

    - Invented new data structure: Hash Trie

### AI software too slow

- in Lisp
- rewrite into C/C++, but C/C++ is a nightmare
  - Create objects temporaily uses (C/C++ requires explicit free/dealloc operations)

Can you suggest some better languages for this problem?

### Why are there so many programming languages?

- Why can't we have just one, one that is flexible?

Metaprogramming: programming environment that you can write about your code in the language that you are using that can be used to generate code.

- Modern: Have many languages in a project & link together
- Not practical to take python program and compile into scheme and expect to work

### Big backend queries in Google's data

- Written a lot of Ad-hoc programs to deal with this problem
- Shell scripts (parallelized), not scalable

- A function model
  - stolen from Lisp/ML
  - called it **MapReduce**
  - _efficient_ & _parallelizable_

### TIOBE Index Sept 2015 (most popular programming languages)

1.  (19.57%) Java
2.  (15.62%) C
3.  (6.78%)  C++
4.  (4.91%)  #C
5.  (3.66%)  Python
6.           PHP
7.           JavaScript
8.           VB.NET
9.           Perl
10. (1.82%)  Objective-C
    ......
33. (0.51%)  Prolog
    ......
47. (0.21%)  ML

Choose a few languages wide apart from goals & principles

### Philosophy of Class

* Principles & Limitations of Programming Models
* Notations for these Models, Designs, Use, Support For
* Methods to Evaluate Strenths + Weaknesses in Various Contexts

--> **CHOICE OF ABSTRACTION**

#### Language Design Issues

* Orthogonality: how independent are they of each other

Language: C
------------
`int f(int g) {}`
`char *f(int g) {}`
`int [100] f(int g) {}` (cannot work, cannot return array)
  - violation of orthogonality (have to worry about return type)
  - return value does not fit in register (efficiency)

Java can return arrays (fixed problem, more modern language)

* Efficiency
  - space, time, power, network access

* Simplicity
  - Thins should be as simple as possible (Albert Einstein)

* Convenience
  - Easy to use (write code, read code)

**Simplicity & Convenience CONFLICT**

Example: Convenient but not Simple
```
i = i + 1;
i += 1;
i++;
++i;
```

* Safety (Security Issues)
  - compile-time (complier warnnings about safety)
  - run-time (run-time good enough to handle problems)
    - C++ (crash if lucky, undefined behavior if unlucky)

# Sep. 30, 2015

## Programming Language Catetories

Imperative vs. Functional vs. Logic
Objective Oriented vs. Non Objective Oriented
Compiled vs. Scripting

### Imperative/Procesural Languages (most common & popular)

**COMMANDS**

* In sequence

### Functional Languages

**FUNCTIONS**

* NO commands
* Evaluate expression
* Calling functions
* F1(F2(x)) (Can also use C this way)

### Logic Languages

**PREDICATES**

* P1(x) & P2(x)
* Don't evaluate
* Don't execute
* Theorem proving program (?)
* Highest level


## John Backus

* Developed Fortran

* Discovered that imperative code had problems, buggy code
* Hard to understand
* Sequencing is crutial

* Adopting the imperative style sets programmers off from the mathematics world
* Breaking the rules of the mathematical world

```
y = a[i];
i++;
x = a[i];
```

**a[i] CHANGES!!!**

## New Habit **(!)**

* No assigning variables
  - OCaml: variables in functions cannot change
  - Referential transparency

## Functional Language Motivation

Clarity
--------
* Build on hundreds of years of experience with **mathematical notation**

Notation
---------
* To compute with functions rather than recipes (sequential steps)
* **Function Definition**: mapping from a **domain** to a **range**
  - Figure out what domains & ranges are
  - Domains & ranges may include functions themselves
  - Functional form: domain or range are functions
    + `F [o](compose) G (x) = F(G(x))`
      - `[o](compose)` is a function that takes functions as inputs

Performance
------------
* von Neumann bottleneck

```
  +-----+  --->  +-----+
  | CPU |        | RAM |  (not parallel)
  +-----+  <---  +-----+
```

* Get better clarity and performance with functional style

```
(1) a = f(b,c);
i++;
(2) x = g(y,z);
```
Can execute (1) & (2) in parallel only if f() & g() don't look at i

* Try to figure out methods to write code without assignments
* Assignment statments lead to undefined behavior

## OCaml

* General-purpose
* Object-oriented
* Has assignment statements (but don't use)
* OCaml (SoCal) != ML (East-coast)

* Has both compiler & interpreter

```
    OCaml                                ML
-----------------------------------------------------------------
x < y && y < z                 x < y and also y < z
  3. +. 1.5                         3. + 1.5
   [1;2;3]            [1,2,3]  can also use for tuples (1,"abc")
-----------------------------------------------------------------
```

Basic Properites
-----------------
* Good support for **functions** + **functional forms** (much better than in Java or C)
* **Compile-time type checking** (like C++, Java) (unlike Python, Scheme)
* Heavy-duty **type inference**
* No need to worry about storage management, has **garbage collection** (unlike C/C++) (like Java, Python)

### Startup

Start by using `$ ocaml`

```
# 3 + 4 * 5;;
-: int = 23
# let x = 37 * 37;;
x: int = 1369
# if 3 < 5 then "a" else "b";; (* 3<5?"a":"b" in C *)
-: string = "a"

# if 3 < 5 then "a" else 0;;
[error, wrong type]

# (1,2, "a");; (* tuple *)
-: int * int * string = (1, 2, "a") (* cross product for '*' *)
# [1; 2];;
-: int list = [1, 2]

# ();;
-: unit = ()
# [];;
-: 'a list = []

# [1; 3] @ [5];;
-: int list = [1; 3; 5]
# [1; 3] @ [];;
-: int list = [1; 3]

(* functions *)
# let f x = x + 1
# let f = fun x -> x + 1;;
val f: int -> int = <fun>

# let cons (a,b) = a::b;;
val cons: 'a * 'a list -> 'a list = <fun>
# let cons x = match x with | (a,b) -> a::b;;
```

### Paterns in OCaml

```
patterns        what they match
--------------------------------------------------
0               0
--------------------------------------------------
[]              []
--------------------------------------------------
a,b             any tuple of 2 elements
                (binds 1st to a, 2nd to b)
--------------------------------------------------
h::t            binds h to 1 element, t to
                remaining list (can be empty)
--------------------------------------------------
(a,b)::t        (group patterns)
--------------------------------------------------
a               matches anything, binds to a
--------------------------------------------------
_               matches anything & discards
--------------------------------------------------
_,b             discards first, binds second to b
--------------------------------------------------
```

* match expressions

```
match x with
  | P1 -> E1
  | P2 -> E2
  | Pn -> En
```

```
match l with
  | _::_::x::_ -> x
  | _::x::_ -> x
  | x::_ -> x
  | _ -> 0
```

```
# let ccons a b = a::b;;
val ccons: 'a -> 'a list -> 'a list = <fun> (* functional form *)

(* lambda expression, don't need name *)
# let ccons a = fun b -> a::b;;
# let ccons = fun a -> fun b -> a::b;;
val ccons: 'a -> 'a list -> 'a list = <fun>

(* function call is left-associative *)
# ccons "abc" ["def"; "ghi"];;
# (ccons "abc") ["def"; "ghi"];; (* equivalent *)

# let ccons0 = ccons 0
val ccons0: int list -> int list = <fun>
# ccons0 [1; 2];;
-: int list = [0; 1; 2]
```

```
# let hd h::_ = h;;
Warning: hd is a partial function, some patterns won't match
val hd: 'a list -> 'a <fun>
# let hd = fun x ->
  match x with
  | h::_ -> h;; (* Doesn't work on empty lists *)
```

* Always match all patters
* Don't use head and tail functions

Safe head function
```
# let sfhd = function
  | h::_ -> h
  | _ -> 0;;
val sfhd: int list -> int = <fun>

# let safehd d = function
  | h::_ -> h
  | _ -> d;;
val safehd: 'a -> 'a list -> 'a = <fun>
```

### Recursion

* Always write the `rec` keyword

```
(* buggy code *)
# let rec reverse = function
  | [] -> []
  | h::t -> (reverse t) @ h
val reverse: 'a list list -> 'a list = <fun>
# reverse [ [1; 2]; [2; 3] ];;
-: int list = [2; 3; 1; 2]
# reverse [1;2;3];;
Error: This expression has type int but an expression was expected of type 'a list
```

**SLOW CODE**
```
# let rec reverse = function
  | [] -> []
  | h::t -> (reverse t) @ [h]
val reverse: 'a list -> 'a list = <fun>
```













































