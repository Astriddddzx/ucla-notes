
CS180: Algorithm Design and Analysis

Homeworks assigned noon Tue. and due 7:59am Thu.
Office: 3532C BH


=============
Jan. 5, 2016
=============

Al Khowrazmi --> Algorithm


Serial Model of Computation
----------------------------

+------------------------+    +-----+
|                        |    |     |
| +-----------+  +-----+ |    |     |
| | Registers |  | CPU | |    | RAM |
| +-----------+  +-----+ |    |     |
|                        |    |     |
+-----------|------------+    +-----+
            |
           I/O

- CPU can do only basic operations


Example
--------
Add n integers using this model
    |
    +--> 'n' means a large number in algorithm design

Assume reading from I/O to CPU takes about 1 unit of time
        saving from CPU to RAM takes about 1 unit of time

--------------------
read         ~ 2n
RAM to CPU   ~ n
adding       ~ n-1
output       ~ 1
--------------------
total        ~ 4n
--------------------

T(n) = O(n)


We can either improve the algorithm or prove that we cannot


Example: Famous People
-----------------------
everyone knows
he/she does not know anyone


Model of Computation
---------------------

        know
    A --------> B       takes 1 unit of time


Ask 2(n-1) questions to know if one person is famous or not
Cannot have second famous person or else contradiction

We repeat for each person in class      2(n-1)  --+
                                        2(n-1)    |
                                        2(n-1)    +--> n times
                                         ...      |
                                        2(n-1)  --+

n * 2(n-1) = 2n^2-2n
           ~ 2n^2
           ~ n^2


Reduce size of problem, eliminate candidates


Random vs. Arbitrary


Pick 2 arbitrary people

                   yes
      know      +-----> A is not famous
  A --------> B +
                +-----> B is not famous
                  no

After n-1 questions only 1 candidate
Ask 2(n-1) questions about the last candidate to verify

3(n-1) --> ~ n


Asymptotic Analysis
--------------------

-------------
   n = 10
-------------
  n    10      --+
 2n    20        +---> polynomial
n^2    100     --+
        
2^n    1014    --+
 n!    4M        +---> exponential
-------------  --+


f(n) = O(g(n))    ---->   about or less, order of
if there exists constants n0,c such that
f(n) <= cg(n)    n >= n0


f(n) = O(n^2)

n^2/4
5n^2
logn
2^n   is not order of n^2


=============
Jan. 7, 2016
=============

Develop general methodologies that can be applied to general cases

---------------------
The Matching Problem
---------------------
In a group, match two people with each other
one-to-one, one person can only match with another single individual

two groups: male and female, each with n people
match one male with one female

    M1        W1

    M2        W2

    M3        W3

    M4        W4

assume each person has an ordering list (preference list)

    (W', W)
        M ---- W
         /\
           \
            \      double arrow as shown means unstable
             \
              \/
        M' --- W'
            (M, M')


generic step for inductive algorithm
-------------------------------------
if M is not matched, M will pick the highest woman on his list and propose
  if W is not matched, she will accept the proposal
  otherwise she will look in her list
    if M has higher priority, she will discard current match, and match with M
    otherwise, she will not accept the match


M will get worse matches eventually (down priority list)
W will get better matches eventually (up priority list)


how to prove that this is stable?
----------------------------------
assume by contradiction that we get an unstable result as follows

    M ---- W
     /\
       \
        \
         \
          \/
    M' --- W'

case 1 :  M did not propose to W'
          contradiction to algorithm because W' is higher on M's list
          so M must have proposed to W' first before matching W

case 2 :  M did propose to W'
          since M is higher on priority list of W' and M proposed to W'
          W' should be matched with M, so contradiction
          M" > M > M', so W' is matched to M", not M', so contradiction

How to show perfect match?


==============
Jan. 12, 2016
==============

For every given problem we do not want a totally new algoritm
so we will study algorithmic paradigms

But let's start with a few examples

-----------------------
The Scheduling Problem
-----------------------
Given set of intervals, want to find a subset
We cannot overlap tasks, and cannot do tasks partially

      S     E
      +-----+        +---+
         a             b
           +-----------+
                 c
       +---+       +-----+
         d            e
            +-----+   +---+
               f        g

Sa <= Ea

Want to maximize the NUMBER of intervals
Length of interval does not matter

    +-----------------+ +---------------+
             a                  d

        +---+ +---+
          b     c

    Can pick 'a' or 'b', both have same cardinality |a| = |b|
    However, we should pick 'b' and 'c' instead of 'a'
    Then we should pick 'b' and 'c' and 'd', which has cardinality 3


exhausive search algorithms vs. greedy algorithms


Solve first using exhausive search
-----------------------------------
Pick every subset
write the solution as a binary number

  10110   means that for each bit turned on, we pick corresponding interval
  abcde   in this case, we pick 'acd'

This algorithm takes o(2^n Tn), which is too slow


Solve using greedy algorithm
-----------------------------
Pick one and stick with it, will not change it later
Pick according to length of time interval (E - S)

Pick the shortest interval, exclude any other that overlap with it
Pick the next, and exclude any other that overlap with it
Repeat the process

This does not work
                       a     b
    +--------------------+ +--------------------+
                       +-----+
                          c


What if we choose the interval that has the fewest number of conflicts
This does not work either (try to prove it)


Solve using plane sweep
------------------------
Starting point is an event, ending point is an event

Start from -inf to inf, choose first starting event
Whenever we encounter an event, decide what to do
  Encounter a Start, include it and exclude any overlapping intervals
  Repeat the process until we are out of choices

This does not work

               a
    +---------------------+
            b     c
          +---+ +---+


What if we choose the first ending event
We cannot find counter example, let's try proving that it works

Proof by Induction
-------------------
Assume that we have an optimal solution all the way up to the 'i'th selection

Base case: Choose the first interval, it is optimal
Inductive Step:

------------+---------------------
     i      |        i + 1
------------+---------------------
            |
     x      |    a
+---------+ | +-----+
            |
     x      |         b
+---------+ |      +-----+
            |

Ea <= Eb
Sb >= Ex
Sa >= Ex


Runtime analysis
-----------------
1. sort the endpoints                  O(nlogn)
2. pick the first ending interval
   remove the overlapping ones         O(n)


==============
Jan. 14, 2016
==============

Suppose we have integers as follows, would like to sort in non-decreasing order

    6 2 4 9 1 5 7 3

Technique: reduce problem size
           Famous Problem: reduce problem size from n to n-1

Methodology: Divide and conquer
             keep dividing until it is small enough
             'glue' back together

    Merging
    --------
    Two lists A and B

      A       B
    +---+   +----+        +----+
  ->| 2 | ->|  6 |        |  2 |
    | 4 |   | 10 |        |  4 |
    | 7 |   | 11 |  --->  |  6 |
    | 8 |   | 14 |        |  7 |
    | . |   |  . |        |  8 |
    | . |   |  . |        | 10 |
    +---+   +----+        | 11 |
      s       t           | 14 |
                          | .. |
                          +----+

    runtime of merging O(st)
    a better runtime analysis is O(s+t)


    6 2 4 9   1 5 7 3               ----+
                                        |
    6 2   4 9   1 5   7 3               +----> divide
                                        |
    6   2   4   9   1   5   7   3   ----+

    2 6   4 9   1 5   3 7           ----+
                                        |
    2 4 6 9   1 3 5 7                   +----> merge
                                        |
    1 2 3 4 5 6 7 9                 ----+

    
Runtime analysis of mergesort
------------------------------
T(1) = O(1)
T(n) = 2T(n/2) + O(n)
     = 2T(n/2) + cn
     = 2[2T(n/4) + cn/2] + cn
     = 2^2 * T(n/2^2) + 2cn
     = 2^3 * T(n/2^3) + 3cn 
     = 2^i * T(n/2^i) + icn

find out for what values are  n/2^i = 1
                           -> 2^i = n
                           -> i = logn

     = 2^logn * T(n/2logn) + logn * cn
     = n + cnlogn

The algorithm is O(nlogn)


Closest pair problem
---------------------
Assume we have a set of points in a 2-D space

Computing distances takes O(1) time

Runtime
--------
n-1
n-2
 .
 .
 .
 1

sum(i=1,n) i = n(n+1)/2

Thus it takes O(n^2) time

Find minimum value of list
---------------------------
12 4 1 9 11 6 18
keep local variable min = 12
search through each element and compare with min

takes O(n) time, with n-1 comparisons


==============
Jan. 19, 2016
==============

Graphs
-------

G = (V, E)
     |  |
     |  edges (pair of vertices)
     |
     vertices / nodes


Simple Graph (Basic version of graph)
--------------------------------------
Unweighted graphs: no weight on vertices/edges
Undirected graphs: no direction on edge (unordered pair of vertices)
No parallel edges (pair of vertices appearing multiple times)

Using adjacency matrix to represent graph
------------------------------------------
each entry a(i, j) in matrix tells if there is an edge between
vertices i and j, either 1 (there is edge) or 0 (no edge)

for weighted graph: use weight instead of 0 and 1
for directed graph: edge between i and j does not imply edge between j and i

      1 2 3
  +-----------
1 | [ 0 0 1 ]
2 | [ 1 0 1 ]
3 | [ 1 1 0 ]
  |

matrix representation takes space (n^2 entries)
fast for checking if nodes are connected

Using linked list to represent graph
-------------------------------------

1 --> 2 --> 5
2 --> 1
3

does not take as much space as adjacency
basic operations take more time

Path        Takes from vertex i to vertex j
            simple path: no repeated edges and vertices

Cycle       Path that takes vertex i back to i
            simple cycle: no repeated edges and vertices (except first)

Connected   If we can reach any vertex from any vertex

Maximum number of edges: C(n 2)     dense graph
Minimum number of edges: n - 1      sparse graph


Breadth First Search (BFS)
---------------------------
search the close nodes first
use a first in first out queue

runtime: O(|E|)  -->  also O(n^2) (but not as tight)
            |
            number of edges

'jump' between components if graph is not connected
then runtime: O(|E|+|V|)

Length of path: number of edges from beginning to end vertex

Bread First Search Tree
Connect the vertices that vertex i is searched through first


Depth First Search (DFS)
-------------------------
search the nodes next first

Edges that allow to see node for first time form a DFS tree
Edges that allow to see node for second or more times are backward edges
    - this implies cycles in the graph

Give algorithm to determine if there are cycles in graph
Run depth first search to determine backward edges

runtime: O(|E|)


Majority Problem
-----------------
Majority: person with more than n/2 number of votes
either no majority or exactly one majority

Count number of vote see if anyone has more n/2 votes

Majority candidate must pass middle line
runtime: O(nlogn)
Find O(n) time algorithm to solve this problem

Pick two different elements, get rid of them, until we have 2 left
If they are different, then we have no majority
If they are the same, then it is the majority
In the end we should double check

Keep local 'maj-candidate' variable, and count of votes

2 3 2 2 2 3 2 1

get rid of 2 3  -->  2 2 2 3 2 1

maj-candidate: 2, 3


* What about 1 1 2 2 2 3 3 ?


==============
Jan. 21, 2016
==============

Connected and Directed Graphs
------------------------------
this kind of graph has nodes where each node has a direction
it may or may not have a cycle, which depends on direction

Techniques for BFS and DFS are the same except the definition of 'neighbor' is
different in that we have to follow the direction of the node instead of
simply getting the 'adjacent' nodes.

Directed Acyclic Graph      directed graph with no cycles
                            widely studied, many applications
                            use DFS to determine if there are cycles


Topological Soring a Graph
---------------------------
must be a DAG
there is no way to topologically sort a graph with a cycle

    +-->a --> b --> c --+
    |                   |
    +-------------------+

    no way to sort this graph topologically


            a
           / \
          b   c
          | \ |
          |  \|
          d   e

ordering: a c b e d

no precedence relationship between 'b' and 'c'

In degree of vertex     ingoing edges of the vertex
Out degree of vertex    outgoing edges of the vertex

In-deg = 0  -->  Source     could have n-1 sources
OUt-deg = 0 --> Sink        could have n-1 sinks

Degree of vertex (undirected)   number of connected edges


Topological Sorting Algorithm
------------------------------
for a DAG with n nodes, we can have n! (total ordering) orderings
consider a graph with n sources and 1 sink

in an ordering there is no pointer from a later node to an earlier node


building the algorithm high-level
----------------------------------
generate a list of sources
output a source
remove the source and outgoing edges from the outputed source
update the list of sources
output a source

... repeat ...


details of algorithm
---------------------

(1) first go through all vertices and edges and update in-deg and out-deg

          a ------------> b
       in-deg = 0     in-deg = 0
      out-deg = 0    out-deg = 0

  whenever we find an edge, compute the in-deg and out-deg of the two vertices
  in this case, in-deg(a)++ & out-deg(b)++

  worst case analysis
    O(n^2)       every vertex can be compared to (n-1) other nodes
    O(|E|)       |E| = number of edges (tighter analysis)

  'linear' algorithm means linear in the input size, nothing else
  in this case we need algorithm linear in |V|+|E| (number of vertices & edges)


(2) go through all vertices (n), check their in-deg and build list of sources
    need data structure that inserts and extracts elements in O(1) time

    since we have n nodes, this runs in O(n) time


(3) when we look at a source, we decrement the in-deg of the pointed nodes
    one single step could take n-1 comparisons with n-1 nodes
    so this step would take O(n^2) time
    or we could simply say that we make one move per edge, takeing O(1) time
    since we have |E| edges, this takes O(|E|) time

--------------------------------------------------------------------
NP-complete problems : nobody knows how to solve it in linear time
NP-hard problems     : also very hard (travelling salesman problem)
--------------------------------------------------------------------

Bipartite Graphs
-----------------
a graph is bipartite if I can take a graph and partition it into two groups
and that the edges of the graph go only from group 1 to group 2 such that
there are no edges between two nodes inside the same group

(1) Can we draw any graph as this way? In essense are all graphs bipartite?
    This cannot happen. Take the simplest example

                        *
                      /   \
                     *-----*

    Any graph with an odd cycle is not bipartite

(2) Can we prove that any graph without an odd cycle is bipartite?
    This is the key to this algorithm

Use BFS in this case, and use its runtime analysis


==============
Jan. 26, 2016
===============

f(n) = Omega(g(n))
if there exists c, n0 such that
f(n) >= cg(n) when n > n0

    To improve the lower bound we have to increase it
    To improve the upper bound we have to decrease it
    Ideally we want the lower bound and upper bound to match

f(n) = Theta(g(n))
if there exists c1, c2, n0, n1 such that
c1g(n) <= f(n) <= c2g(n) when n0 < n < n1


Comparison Exchange Model
--------------------------

       Decision Tree
                            a:b
                          /     \
                         /       \
                        /         \
                       /           \
                  a > b             b > a
                    /                \
                 a:c                  b:c
                /   \                /   \
           a > c     a < c      b > c     b < c
              /       \            /       \
           b:c        *cab       a:c       *cba
          /   \                 /   \
     b > c     c > b       a > c     c < a
        /       \             /       \
      *abc      *acb        *bac      *bca


# leaves >= n!
height >= log(n!)
       >= Omega(nlogn)

T(n) = Omega(nlogn)
     = Omega(n)


Binary Search
--------------
+------------+-+-----------+
|            | |           |
+------------+-+-----------+
1             x           n

find k in the list, which is sorted

Take the middle value x
(1) x = k, done
(2) x > k, get rid of right-half of list
(3) x < k, get rid of left-half of list

T(n) = T(n/2) + C
     = O(logn)
T(n) = Omega(1)    ->    trivial lower bound


Circularly Sorted List
-----------------------

    9 11 14 2 5 7 8

targets:  O(n^(1/2))  O(logn)  O(1)
                      ^
                      |
                bet on this one

compare middle of the list with the head and tail of the list
if middle = target, done


==============
Jan. 28, 2016
==============

Greedy Paradigm
----------------
Pick an element and stick with it, without looking at global solutions
Usually local, not global, which takes more time to prove optimal
Fast and efficient

----------------------------------
Example: time interval scheduling
----------------------------------
a set of time intervals
any number of processors
cannot change start/end time

want to minimize number of processors

Algorithm
----------
1. sort every interval according to start time

At any random step

    p3  |-----|
    p2  |---| |-----|
    p1  |------| |------|  <---   assgin to p1 and we're done
                     ^
---------------------|-------------------------------------
                     |
                 |------| |------|
                    |--------| |-------|

this is greedy because we assign a task to a processor and never change it

How to prove this algorithm?
-----------------------------
Assume up to k'th step that the algorithm is correct but at k+1 step we assign
a task to a wrong processor.
Let's assume that we assign task i to p1 instead of p3
Then for p1, the following assignments can be exchanged into p3 and will work
Thus we have a contradiction and the algorithm is optimal

----------------------------------
Example: shortest path in a graph
----------------------------------
Suppose we have a weighted undirected connected graph with positive or
negative numbers as edge weights
Assume no negative cycles, because shortest path will be -INF
Assume all weights are positive


algorithm is greedy so we want to pick a path without changing it


    S ------
    | \
    |  \
    |   \
    |    \

Of all neighbors of S, we pick the shortest edge adjacent to S
At any given time based on edges and vertices we have observed so far
pick the minimum value
Then we claim that this is the smallest
Number of links in this algorithm is irrelevant

time complexity
----------------
min t -> x                          n
fix its distance                    1
move neighbors of x to frontier     n-1
-------------------------------------------
total time complexity               O(n^2)


Minimum Spanning Tree
----------------------
A tree has no cycles
Remove edges from a graph to build a tree (span tree)


