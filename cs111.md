# CS111: Introduction to Operating System Principles

# Sep. 24, 2015

Administrative
---------------
* Peter Reiher
* Office Hours: 3532F Boelter Hall (T,Th 1-2pm)

* Instructor: lectures, readings, tests
* TA: projects

* [Class Website](http://www.lasr.cs.ucla.edu/classes/111_fall15)
  - schedules for readings, lectures, exams. projects
  - copies of lecture slides
  - announcements

Course Format
==============
* Two weekly (20 page) reading assignments
* Two weekly lectures
* Four (10-25 hour) team projects
* One design project (10-25 hours)
  - working off one of the team projects

* [Textbook](http://www.sciencedirect.com/science/book/9780123749574)

Tests
======
- Midterm    25%   ->   (closed-book) 10-15 essay questions (short answers)
- Final      30%   ->   (open-book) 6-8 hard multi-part essay questions (pick subset)
- Projects   45%   ->   4 regular projects, 2 mini-projects (solo / team of 2)

## Why study operating systems?

* Build on concepts from other courses
  - data structures, programming languages, assembly language, computer architectures

* Why study OS?
  - Setup, configure, manage computer systems
  - Write programs that exploit OS features
  - Work with complex, distributed, parallel software
  - Work with abstracted services and resources

* Many hard problems are found in OS context
* Many hard problems solved in OS context
  - synchronization, security, integrity, protocols, distributed computing, dynamic resource management

* High standards
  - performance, correctness, robustness
  - scalability, extensibility, reusability

* Policy (how to do something) vs. Mechanism (mechanical way to do something)
  - Policy determines what can/should be done
  - Mechanism implements basic operations to do it
  - Mechanisms shouldn't dictate or limit policies
  - Policies must be changeable without changing mechanism

* Parallelism and aysnchronoy are powerful and necessary
* Performance and correctness are often at odds

Interfaces
===========
* An interface specification is a contract
  - Specifies responsibilities of producers & consumers
  - Basis for product/release interoperability
  - Cannot break the contract

* Interface vs. Implementation
  - An implementation is not a specification
  - Many complaint implementations are possible
  - Inappropriate dependencies cause problems

* Modularity and functional encapsulation
  - Complexity hiding and appropriate abstraction
  - Divide complex project into simples sub-projects

## Basics of operating systems

* Abstracted resources
  - simplifying, generalizing
  - serially reusable, partitioned, sharable
    + Linux (reuse files): uses files to represent everything
    + World Wide Web (reuse URLs): uses URL to create links

What is an OS?
---------------
- It is low level software (bottom right above hardware)
  - Provides more usable interface for hardware
- Provides better, more usable abstractions of the hardware below it
- Allow easy, safe, fair use of sharing resources

* Manages hardware for programs
  - Allocates hardware and manages its use
  - Enforces controlled sharing (and privacy)
    + OS allows access and denies access to files
  - Oversees execution and handles problems
    + Deals with hardware problems
    + Deals with software problems
    + Makes sure other software is not affected by one software

* Abstracts the hardware
  - Makes it easier to use and improves software portability
  - Optimizes performance

* Provides new abstractions for applications
  - Powerful features beyond the bare hardware
    + Floating point software makes it look like we have floating point hardware

* Set of management & abstarction services
  - Invisible, happens behind scenes

* Applications see objects and their services
  
  - CPU supports data-types and operations
    + bytes, shorts, longs, floats, pointers ...
    + add, subtract, copy, compare,  indirection ...
  
  - So does OS, but at higher level
    + files, processes, threads, devices, ports ... 
    + create, destroy, read, write, signal ...

* An OS extends a computer
  - Create a much richer virtual computing platform
    + support richer objects, more powerful operations



Operating System
-----------------

```
                          Application Software   +-------------+
                        -------+----------------               |
                               |                               |
                               +                               |
                Application Binary Interface                   |
               ----------------+-------------                  |
                               |                               |
                               |                               |
                 +------------ * ----------------+             |
                 |  System Services / Libraries  +-+           |
                 +--------+----------------------+ |           |
                          |                        |           |
                          +                        |           |
               System Call Interface               |           |
              ------------+----------              |           |
                          |                        |           |
                          |                        |           |
         +--------------- * ------+                |           |
         |    Operating System    +---+            |           |
         +---+--------------------+   |            |           |
             |                        |            |           |
             +                        |            +           +
       Privileged Instruction Set     |        Standard Instruction Set (Shift, Jump)
      -------+--------------------    |       -----+-----------+----------------------
             |                        |            |           |
             |                        |            |           |
+----------- * ---------------------- * ---------- * --------- * -----------------------+
|       Hardware (arithmetic, logical, copy, test, flow-control operations, ...)        |
+---------------------------------------------------------------------------------------+
```


What's special about the OS
----------------------------
* It controls the hardware
  - Automatically loaded when machine boots
  - First software that accesses hardware
  - Continues running while apps come & go (**OS ALWAYS RUNS**)

* It alone has **complete access** to hardware
  - Privileged instruction set, all of memory & I/O

* It mediates applications' access to hardware
  - Block, permit, or modify applciation requests

* It is trusted
  - To store and manage critical data
  - To always act in good faith

* If the OS crashes, it takes everything else with it

What functionality is in the OS?
---------------------------------
* As much as necessary, as little as possible
  - OS code is **very expensive** to develop and maintain
  - Movement of super-small OS

* Functionality must be in the OS if it
  - Requires use of privileged instructions
  - Requries the manipulation of OS data structures
  - Must maintain security, trust, or resource management

* Functions should be in libraries if they
  - Are a service commonly needed by applications
  - Do not actually have to be implemented inside OS

* But there is also the performance excuse
  - Some things may be faster if done in the OS

Where to offer a service?
--------------------------
* Hardware, OS, library, or application?
* Increasing requirements for stability as you move through these options
* Hardware services rarely change
* OS services can change, but it's a big deal
* Libraries are a bit more dynamic
* Applications can change services much more readily

* Things everybody uses belongs in lower hierarchy
* Things used by fewer people belong higher

OS & speed
-----------
* There's a push to move services with strong performance requriements down to the OS

# Sep. 25, 2015

## CS111 Lab 1A

* Zhaoxing Bu (zbu@ucla.edu)

Algorithm
----------
1. Operator Stack (Goal: empty this stack)
2. Command Stack

3. Lists 

```
If encounters new command:
  push on command_stack
If encounters new op:
  If operator_stack == NULL:
    Add new op to operator_stack
  Else:
    If precedence(new op) > precedence(top op):
      Add new op to operator_stack
    Else:
      While top op != '(' && precedence(new op) <= precedence(top op):
        operator = operator_stack.pop()
        seccond_command = command_stack.pop()
        first_command = command_stack.pop()
        new_command = combine(first_command, second_command, new op)
        command_stack.push(new_command)
        top_operator = operator_stack.peek()
        if top_operator == NULL:
          break
    operator_stack.push(new operator)
    blah blah
  process whatever is left in operator_stack
```

# Sep. 29, 2015

### What kind of functionalities should we have & what not?

* Keop OS small
* Performance, maintanence

- More Code
  * Safety

* Some operation requries OS services
  - Why not put operation into OS?
  - Move into OS = more code in OS
  - Faster if moved into OS (less overhead, less context change, invalidated cache)
    + Perfomance penalities
  - All instructions run at certain speed

* OS has complete access to all devices
  - Easy to work with hardware in OS

* Fiddling with memory is also faster in OS
* However this doesn't mean faster speed, instructions operate at the same speed as before
* Should not put service in OS just because it runs faster

## The OS and Abstraction

* Intended to turn low-level stuff to less-complicated & easier-to-use high-level stuff
* Implements the abstract resources using the physical resources
  - Virtual memory
  - Files are abstractions of physical disk
* Abstractions are easier to use, easier to understand
* Compartmentalize/encapsulate complexity
  - Each user has its own boundaries
* Get rid of behavior irrelavent to the user
  - Disk drive -> irrelevant behavior when disk drive is fetching data
  - Errors -> bad block on disk drive (find another block to write? report?)
* Create more convenient behavior
  - Higher-level
  - Make it look like you the network is at your own use

* Make many different types appear to be the same
  - Applications deal with the same common class
  - Applications don't have to deal with each specific case
  - Generalized class
* Usually involves a common unifying model
  - Every detail works below for you
  - Portable documnent format (pdf) for printer
* Usually involves a _federation framekwork_
  - (*User*) Interface  --> (*OS*) Customize (software) and translate general to specific device
  - Per sub-type implementations of standard funcitons

### Why do we want this generality?

* Write applications against a single model, and have it "just work" with all "printers"
* What's the alternative?
  - Program application to know about all "printers"
  - Including those that are invented in the **FUTURE**

### Does a general model limit us?

* Does it stick us with the "least common denominator" of a hardware type?
* No necessarily
  - Model can include "optional features"
    + If present, implemented in a standard way
    + If not present, test for them and do "something" if they're not thre
  - Extensibility
    + Offer options (some prefined)
    + Options can be programmed by user
* Many deivces will have features not in the common model

## Common types of OS Resources

Serially Reusable Resources
----------------------------
* Used by multiple clientes, but only one at a time
  - Time multiplexing
* Require access conrol to ensure exclusive use
* Require graceful transitions from one user to the next
  - A switch that totally hides the fact that the resource used to belong to someone else
  - Don't allow first user's usage to be know to the second user (flush, clean)
  - No incomplete operations that finish after transition
  - No traces of data or state left over from the first user
  - Ensure that each subsequent user finds the resource in "like new" condition
* Examples: printers, bathroom stalls, keyboards, mice

Partitionable Resources
------------------------
* Divided into disjoint pieces for multiple clients
  - Spatial multiplexing
* Needs access control to ensure
  - **Containment**: you cannot access resources outside your partition
  - **Privacy**: nobody else can access resources in your partition
* Examples: disk space, hotel rooms

Sharable Resources
-------------------
* Usable by multiple concurrent clients
  - Clients do not have to "wait" for access to resource
  - Clients don't "own" a particular subset of resource
* May involve (efficiently) limitless resources
  - air in a room, shared by occupants
  - copy of the OS, shared by processes
* May involve **under-the-covers** multiplexing
  - Cell-phone channel (time & frequency multiplexed)
  - Shared network interface (time multiplexed)

### Brief history of OS

Early computers
----------------
* Usage
  - Scheduled for use by user one at a time
* Input
  - Paper cards, paper tape, magnetic tape, dip switches
* Output
  - Paper cards, paper tape, print-outs, magnetic tape, lights
* Software
  - Compilers, assemblers, math packages
  - No "resident" OS
  - Typically one program resident at a time
* Debugging
  - In binary, via lights and switches

Batch computing (1960s)
------------------------
* Typified by the IBM System/360 (mid 1960s)
  - Programs submitted and picked up later
  - Input and output spooling to tape and disk
* Goals: efficient CPU use, maximize throughput
  - Computer was an expensive resource to be shared
  - I/O able to proceed with minimal CPU
  - Overlapped execution and I/O maximize CPU usage
  - Limited multi-tasking ability to minimize idle time
* Software
  - Batch monitor ... to move from one job to the next
  - I/O supervisor .. to manage background I/O
* Debugging (hex or octal via paper core dumps)
  - Long analysis cycle between test runs

Time sharing (1970s)
---------------------
* Typified by IBM/CMS, Multics, UNIX
  - Multi-user, interaction through terminals
  - All programs and data stored on disk
* Goals: sharing for interactive users
  - Interactive apps demand short response time
  - Enhanced security required to ensure privacy
  - Real-time interaction (context switches)
* OS and system services expanded greatly
  - Terminal I/O, synchronization, inter-process communication, networking, protection, etc.
* False parallelism
  - People seem to be getting results simultaneously

#### How do batch & multitasking differ?

* No interaction between tasks in a batch system
  - Each thinks it has the whole computer to itself
  - Parallel tasks in a timesharing system can interact
* Time sharing system wants to provide good interactive repsonse time to every task

Workstations (Distributed Systems) & PCs (1980s)
-------------------------------------------------
* PCs returned to single user paradigm
  - Initially minimal I/O and system services
  - File systems & interactively from timesharing systems
* Advent of personal productivity applications
  - High end applications gave rise to workstations
* Advent of local area networking
  - File transfer and e-mail led to group collaboration
  - The evolution of work groups and work-group servers
* PCs and workstations "grew together"
* OS worked for one user, but ran multiple processes for him

Embedded Systems (1990s)
-------------------------
* General purpose systems vs. appliances
  - Running software vs. performing a service
* Many appliances based on computers
  - Video games, CD players, TV signal decoders
  - Telephone switches, avionics, medical imaging
* Appliances require increasingly powerful OSs
  - Multi-tasking, networking, plug-n-play devieces
* General purpose OS becoming more appliance-like
  - Ultra-high availability, more automation
  - Easier to use, less management intensive
  - Reliable OS that doesn't crash
* Take utilities needed, discard the others

Client/Server Computing (1990s)
--------------------------------
* Computing specifically designed to provide services accross the network
  - To multiple distinct users, but using the same service
  - Centralized file and print servers for work groups
  - Centralized mail, database servers for organization
  - World Wide Web for everybody
  - Clients got thinner, servers became necessary
* Wide-Area Networking
  - No longer just on a LAN
  - E-mail, HTML/HTTP and the World Wide Web
  - Electronic business services

Distributed and Cloud Computing (2000s)
----------------------------------------
* Distributed Computing Platforms
  - Single servers could't handle required loads
  - So servers offered by/among groups of systems
    + Sometimes load balancing, sometimes functionally divided
  - System services must enable distributed applications
* More recently, move to general remote distributed pools of computers
  - Cloud computing
  - Providing arbitrary distributed computing for many users
* Renting computer services
* Doesn't know what clients want to do
  - General OS software

Ubiquitous and Mobile Computing
--------------------------------
* Modern devices put great computing power in everyone's hands
  - a typical tablet or smart phone
* Networking available in most places
  - But at varying qualities
  - Perhaps ther local sensing and computation, too
* Most activities require some remote access
  - The "powerful" computer may not be able to do much on its own
  - Often primarily an interface device

### General OS Trends

* They have grown larger and more sophisticated
* Their role has fundamentally changed
  - From shepherding the use of the hardware
  - To shielding the applications from the hardware
  - To providing powerful application computing platform
  - To becoming a sophisticated "traffic cop"
* They still sit between applications and hardware
* Best understood through services they provide
  - Capabilities they add
  - Applications they enable
  - Problems they eliminate

### Another Important OS Trend

* Convergence
  - There are a handful of widely used OSs
  - New ones come along very rarely
* OSs in the same family (e.g., Windows or Linux) are used for vastly differenet purposes
  - Making things challenging for the OS designer
* Most OSs are based on pretty old models
  - Linux comes from UNIX (1970s vintage)
  - Windows from the early 1980s (from DOS, BMS)

### Operating Systems for Mobile Devices

* What's down at the bottom for our smart phones and other devices?
* For Apple devices, ultimately XNU
  - Based on Mach (an 80s system), with some features from ther 80s systems (like BSD Unix)
* For Android, ultimately Linux
* For Microsoft, ultimately Windows CE 
  – Which has its origins in the 1990s

### A resulting OS challenge

* Make changes in the architecture
* But too many
  - Due to compatibility
  - And fundamental characteristics of the architecture
* Requires OS designers and builders to shoehorn what’s needed today into what made CS 111 sense yesterday

## Operating System Basics

### Important OS Properties

* For real OS built and used by real people
* What's most important depends on who you are talking about
  - Users
  - Service providers
  - Application developers
  - OS developers
* All are important clients for operating systems

### Reliability

* Your OS really should never crash
  - Since it takes everything else down with it
* But also needs dependability in a different sense
  - The OS must be depended on to behave as it's specified
  - Nobody wants surprises from their OS
  - Since the OS controls everything, unexpected behavior could be arbitrarily bad

### Performance

* A loose goal
* The OS must perform well in critical situations
* But optimizing the performance of all OS operations not always critical
* Nothing can take too long
* But if something is "fast enough", adding compexity to make it faster not worthwhile
  - Often overlooked by OS researchers and developer
* Complex code comes at a cost (reliability)

### Upward Compatibility

* People want new releases of an OS
  - New features, bug fixes, enhancements
* People fear new releases of an OS
  - OS changes can break old applications
* What makes the compatibility issue manageable?
  - Stable interfaces

### Stable Interfaces

* Designers should start with well specified Application Interfaces
  - Must keep them stable from release to release
* Application developers should only use commited interfaces
  - Don't use undocumented features or erroneous side effects

### APIs

* Application Programming Interfaces
  - A source level interface, specifying
    + Include files, data types, constatns
    + Macros, routines, and their parameters
* A basis for software protability
  - Recompile prgram for the designed architecture
  - Linkage edit with OS-specific libraries
  - Resulting binary runs on that architecture and OS
* An API comliant program will compile & run on any compliant system
  - APIs are primarliy for programmers

### ABIs

* Application Binary Interfaces
  - A binary interface, specifying
    + Dynamically loadable libraries (DLLs)
    + Data formats, calling sequences, linkage conventions
  - The binding of an API to a hardware architecture
* A basis for binary compatibility
  - One binary serves all customers for that hardware
    + all x86 Linux/BSD/MacOS/Solaris/...
* An ABI compliant program will run (unmodified) on any compliant system
* ABIs are primarily for users

### Maintainability

* Operating systems have very long lives
  - Solaris, the "new kid on the block", came out in 1993
  - Even smart phone OSes have roots in the 80s or 90s
* Basic requirements will change many times
* Support costs will dwarf initial development
* This makes maintainability critical
* Aspects of maintainability
  - Understandability
  - Modularity/modifiability
  - Testability 

#### Maintainability: Understandability

* Code must be learnable by mortals
  - It will not be maintained by the original developers
  - New people msut be able to come up to speed
* Code must be well organized
  – Nobody can understand 1 million lines of random code 
  – It must have understandable, hierarchical structure
* Documentation
  – High level structure, and organizing principles
  – Functionality, design, and rationale for modules
  – How to solve common problems
  

### Why a Hierarachical Structure?

* Not _absolutely_ necessary, but ...
* Hierarchical layers usually understandable without compeltely understanding the implementation
* Expansion of one sub-system in a hierarchy usually understandable w/out understanding the expansion of other subsystems
* Other structures tend not to have those advantages

#### Maintainability: Modularity & Modifiability

* Modules must be understandable in isolation
  – Modules should perform coherent functions
  – Well-specified interfaces for each module
  – Implementation details hidden within module
  – Inter-module dependencies should be few/simple/clean
* Modules must be independently changeable
  – Lots of side effects mean lots of bugs
  – Changes to one module should not affect others
* **Keep It Simple Stupid**
  - Costs of complexity usually outweigh the rewards

### Side Effects

* A *side effect* is a situation where an action in one object has non-obvious consequences
  - Perhaps even to other objects
   - Generally not following the interface specification
* Side effects often happen when state is shared between seemingly independent
* Side effects lead to unexpected behaviors
* And the resulting bugs can be hard to find

#### Maintainability: Testability

* OS **must work**, so its developers **must test** it
* Thorough testing is key to reliabilty
  - All modules must be thoroughly testable
  - Most modules should be testable in isolation
* Testability must be designed in from the start
  - Observability of interal state
  - Triggerability of all operations and situations
  - Isolability of functionality
* Testing must be automated
  - Functionality, regression, performance
  - Stress testing, error handling handling

# Oct. 1, 2015

## Critical OS Abstractions

* One of the main roles of an operating system is to provide abstract services
  – Services that are easier for programs and users to work with
* What are the important abstractions an OS provides?

## Abstractions of Memory

* Many resouces used by programs and people releate to data storage
  - Variables
  - Chunks of allocated memory
  –  Files
  – Database records
  – Messages to be sent and received

### The basic memory operations

* Regardless of level or type, memory abstractions support a couple of operations
  - WRITE (name, value)
    + put a value into a memory location specified by name
  - value <- READ (name)

### Some complicating factors

* Persistent vs. transient memory
* Size of operations
  - Size the user/application wants to work with
  - Size the physical device actually works with
* Coherence and atomicity
* Latency
* Same abstraction might be implemented with many different physical devices
  - Possibly of very different types

### Where do the complications come from?

* At the bottom the OS doesn't have abstract devices with arbitrary properties
* It has particular physical devices
  - With unchangable, often inconvenient, properites
* The core OS problem:
  - Creating the abstract device with the desirable properties from the physical devices without them

* A typical file
* We can read or write the file
* We can read or write arbitrary amounts of data
* If we write the file, we expect our next read to reflect the results of the write
  - coherence
* If there are several reads/writes to the file, we expect each to occur in some order
  - with respect to the others

### What is implementing the file?

* Most commonly a hard disk drive?
* Disk drives have peculiar characteristics
  - Long, and worse, variable access latencies
  - Accesses performed in chunks of fixed size
    + Atomicity only for access of that size
  - Highly variable performance depending on exactly what gets put where
  - Unpleasant failure modes
* So the operating system needs to smooth out these oddities

### What does this lead to?

* Great effort by file system component of OS to put things in the right place on a disk
* Reordering of disk operations to improve performance
  - which complicates providing atomicity
* Optimizations based on caching and read-ahead
  - which complicates maintaining consistency
* Sophisticated organizations to handle failures































