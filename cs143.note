
CS143: Database Systems

=============
Jan. 4, 2016
=============

Administration
---------------
Tyson Condie
Textbook: Database Management Systems 3rd Edition, by Ramakrishnan and Gehrke

Project
Java based
SimpleDB from MIT/UW
3 Phases: Files (5%), Operators (10%), Optimizer (10%)

Grading
-------------------------------
Lab 1                    5%
Lab 2                   10%
Lab 3                   10%
Quizz (Wed -> Mon)      10%
Midterm (Feb. 11)       25%
Final                   40%
-------------------------------

https://sites.google.com/site/cs143databasesystems/


Data
-----

Big Data --> store across multiple machines

Types of Data
--------------
unstructured data    :  raw text
structured data      :  names, strings ..
semi-structured data :  xml

* Snapchat is built entirely on Google AppEngine, it has no infrastructure


Definitions
------------
Data Model: collection of concepts for describing data
Schema: description of particular collection of data, using a given data model
Relational Model of Data: relation, basically a table with rows and columns.
                          every relation has a schema, which describes the
                          columns, or fields

Relational Database
--------------------
Provides a basis for high level data language which yields maximal
independence between programs on the one hand and machine representation on
the other (Codd, Turing Award 1981)

Logical data independence: protection from changes in logical structure
Physical data independence: protection from changes in physical structure


Example: University Database

Conceptual Schema
------------------
Students(sid: string, name: string, login: string, age: integer, gpa: real)
Courses(cid: string, cname: string, credits: integer)
Enrolled(sid: string, cid: string, grade: string)

Pyhsical Schema
----------------
Relations stored in unordered files
Index on first columns of Students, first 2 cols enrolled


Database Management System (DBMS)
----------------------------------
Database: integrated and organized collection of data
DBMS: software that stores, manages and/or facilitates access to databases


DBMS Provides the following
----------------------------
* "Declarative" queries & data independence
   say what you want, not how to get it

* Help avoid data corruption

* Protection from other users/jobs/queries
  as if you are the only person accessing the DB

* Fault tolerance and durability
  database is protected even if failures occur in the middle of processing

* Tools and interfaces for building applications



Creating Relations in SQL (DDL)
--------------------------------
CREATE TABLE Students
  (sid CHAR(20),
   name CHAR(20),
   login CHAR(20),
   age INTEGER,
   gpa FLOAT)


CREATE TABLE Enrolled
  (sid CHAR(20),
   cid CHAR(20),
   grade CHAR(20))


Adding and Deleting Tuples
---------------------------
INSERT INTO Students (sid, name, login, age, gpa)
  VALUES ('53688', 'Smith', 'smith@ee', 18, 3.2)


=============
Jan. 6, 2016
=============

Disks, Buffers, Storage
------------------------

To find records for all 18 year old students with GPA's over 2.0
  
  SELECT *
    FROM Students S
   WHERE S.age=18
     AND S.gpa > 2.0;


Generic SQL queries
--------------------
SELECT [DISTINCT] target-list
  FROM relation-list
 WHERE qualification;


Can specify a join over two tables
-----------------------------------
  SELECT S.name, E.cid
    FROM Students S, Enrolled E
   WHERE S.sid=E.sid AND E.grade='B';


Basic Query Semantics
----------------------
1. do FROM clause: Compute cross-product of tables
2. do WHERE clause: Check conditions, discard tuples that fail
3. do SELECT clause: Delete unwanted fields
4. if DISTINCT is specified, eliminate duplicate rows


Aggregate Operators
--------------------

COUNT (*)
COUNT ([DISTINCT] A)
SUM ([DISTINCT] A)
AVG (A)
MAX (A)
MIN (A)

  SELECT COUNT (*)
    FROM Students;

  SELECT AVG (S.gpa)
    FROM Students S
   WHERE S.age=18;

  SELECT COUNT(DISTINCT S.age)
    FROM Students S
   WHERE S.name='Bob';


GROUP BY and HAVING
--------------------
SELECT S.major, AVG (S.gpa) as AvgGPA
  FROM Students S
 GROUP BY S.major
HAVING COUNT (*) > 10;


Why not store data in main memory?
-----------------------------------
1. Costs too much
2. Main memory is volatile

  Note some specialized systems do store entire databse systems in main memory

Disks and Files
----------------
READ   transfer page of data from disk to RAM
WRITE  transfer page of data from RAM to disk

Disk Space Management
----------------------
Lowest layer of DBMS software manages space on disk (using OS file system?)
High levels call upon this layer to

  allocate/de-allocate page
  read/write a page

Best if a request for a sequence of pages is laid put sequentially on disk


Terminlology
-------------
Disk Page      the unit of transfer between disk and memory
               typically set as config parameter for DBMS
               typically between 4KB and 32KB

Frame          unit of memory
               typically same size as the disk page size

Buffer Pool    collection of frames used by DBMS to temporarily keep data for
               use by query processor


Buffer Control Block (BCB)
  frame#
  pageid
  pin_count
  dirty


=============
Jan. 8, 2016
=============

CREATE TABLE Students (
  sid CHAR(20),
  name CHAR(50),
  login CHAR(30),
  age INTEGER,
  gpa FLOAT,
  PRIMARY KEY (sid)
);

CREATE TABLE Grades (
  sid CHAR(20),
  course CHAR(50),
  grade CHAR(2),
  FOREIGN KEY (sid) REFERENCES Students (sid)
)

INSERT INTO Students VALUES ('123', 'ABC', 'abc', 18, 3.7);
INSERT INTO Grades VALUES ('123', 'CS143', 'A+');
DELETE FROM Students WHERE sid = '000';


SELECT g.sid avg(g.gpa)
FROM Grades g
GROUP BY g.sid


==============
Jan. 11, 2016
==============

Bunny 1
--------
SQL queries
Elevator Algorithm

Accessing a Disk Page
----------------------
Time to access (read/write) a disk block
    seek time (moving arms to position disk head on track)
    rotational delay (waiting for block to rotate under head)
    transfer time (actually moving data to/from disk surface)

'Next' block concept
---------------------
blocks on same track
blocks on same cylinder
blocks on adjacent cylinder

Disk Space Management
----------------------
lowest layer of DBMS, manages space on disk
higher levels call this layer for services (allocate/read/write/deallocate)

Buffer Pool
------------
uses main memory as a cache for disk
copies disk page to memory
when buffer pool fills up, uses replacement policy to evict page

Files of Records
-----------------
A tuple is embedded in a record


Average case for I/O operations
--------------------------------
B = # disk blocks in file

-----------------+----------+--------------------+-----------------------
                 |   Heap   |     Sorted File    | Index-Organized File
                 |   File   | (100% Occcupancy)  |   (67% Occupancy)
-----------------+----------+--------------------+-----------------------
Scan all records |    B     |         B          |         1.5B
-----------------+----------+--------------------+-----------------------
Equality         |   0.5B   | log(B) on sort key |      logF(1.5B)
Serach           |          |    B/2 otherwise   |
-----------------+----------+--------------------+-----------------------
Range            |    B     |      log(B) +      |     logF(1.5B) +
Search           |          |  selectivity * B   |      #match pgs
-----------------+----------+--------------------+-----------------------
Insert           |    2     |     log(B) + B     |    logF(1.5B) + 1
-----------------+----------+--------------------+-----------------------
Delete           | 0.5B + 1 |     log(B) + B     |    logF(1.5B) + 1
-----------------+----------+--------------------+-----------------------


==============
Jan. 13, 2016
==============

Clustered vs. Unclustered Index
--------------------------------
A file can be clustered on at most 1 search key
Index-organized implies clustered but no vice-versa
  alt-1 is always clustered
  alt-2 and alt-3 may or may not be clustered

  Clustered 
  ----------
  + more efficient for range searches
  + may be able to do some types of compression
  - maintenance cost
  - can only cluster according to single search key




































